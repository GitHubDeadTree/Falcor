# 功率测量方式修复：感光平面物理面积替换像素面积

## 修改概述

### 问题描述
原来的 `IncomingLightPowerPass` 有两种功率测量方式，都使用了像素面积进行计算，这在物理上是不正确的。根据光电探测器和相机传感器的工作原理，应该使用感光平面的物理面积来计算功率。

### 解决方案
将像素面积计算改为感光平面物理面积计算，并相应调整功率计算方式。

## 实现的功能

### 1. C++ 代码修改

#### 修改了 `computePixelArea()` 函数

**文件**: `Source/RenderPasses/IncomingLightPowerPass/IncomingLightPowerPass.cpp`

**原来的实现** (第91行):
```cpp
float IncomingLightPowerPass::CameraIncidentPower::computePixelArea() const
{
    // Calculate pixel dimensions
    float pixelWidth = sensorWidth / mFrameDimensions.x;
    float pixelHeight = sensorHeight / mFrameDimensions.y;

    // Calculate pixel area
    float pixelArea = pixelWidth * pixelHeight;
    
    return pixelArea;
}
```

**修改后的实现**:
```cpp
float IncomingLightPowerPass::CameraIncidentPower::computePixelArea() const
{
    // Calculate total sensor dimensions (entire photosensitive plane)
    float sensorWidth = 2.0f * distToImagePlane * std::tan(hFOV * 0.5f);
    float aspectRatio = (float)mFrameDimensions.x / mFrameDimensions.y;
    float sensorHeight = sensorWidth / aspectRatio;

    // Calculate total sensor area (photosensitive plane physical area)
    float totalSensorArea = sensorWidth * sensorHeight;

    return totalSensorArea;
}
```

#### 修改了功率计算方式

**文件**: `Source/RenderPasses/IncomingLightPowerPass/IncomingLightPowerPass.cpp` (第255行)

**原来的计算**:
```cpp
// Calculate pixel area
float pixelArea = computePixelArea();

// Calculate power using the formula: Power = Radiance * Area * cos(θ)
float3 power = float3(radiance.r, radiance.g, radiance.b) * pixelArea * cosTheta;
```

**修改后的计算**:
```cpp
// Calculate sensor area (now returns total photosensitive plane area)
float totalSensorArea = computePixelArea();

// Calculate effective area per pixel (distribute total area among all pixels)
uint32_t totalPixels = mFrameDimensions.x * mFrameDimensions.y;
float effectiveAreaPerPixel = totalSensorArea / totalPixels;

// Calculate power using the formula: Power = Radiance * EffectiveArea * cos(θ)
// where EffectiveArea is the portion of photosensitive plane area assigned to this pixel
float3 power = float3(radiance.r, radiance.g, radiance.b) * effectiveAreaPerPixel * cosTheta;
```

### 2. SLANG 着色器修改

#### 修改了着色器中的面积计算函数

**文件**: `Source/RenderPasses/IncomingLightPowerPass/IncomingLightPowerPass.cs.slang`

**原来的实现** (第229行):
```hlsl
// Compute pixel area on the image sensor
float computePixelArea(uint2 dimensions)
{
    // Calculate pixel dimensions
    float pixelWidth = sensorWidth / float(dimensions.x);
    float pixelHeight = sensorHeight / float(dimensions.y);

    // Return pixel area with scaling factor
    return pixelWidth * pixelHeight * gPixelAreaScale;
}
```

**修改后的实现**:
```hlsl
// Compute photosensitive plane physical area for power measurement
float computePixelArea(uint2 dimensions)
{
    // For photodetector analysis, use the physical detector area directly
    if (gEnablePhotodetectorAnalysis)
    {
        // Use the configured detector area for photodetector analysis
        return gDetectorArea;
    }

    // For camera-based analysis, calculate total sensor area (photosensitive plane)
    // Calculate total sensor dimensions (entire photosensitive plane)
    float sensorHeight = 2.0f * distToImagePlane * tan(fovY * 0.5f);
    float sensorWidth = sensorHeight * aspectRatio;

    // Return total sensor area (photosensitive plane physical area) with scaling factor
    float totalSensorArea = sensorWidth * sensorHeight;
    return totalSensorArea * gPixelAreaScale;
}
```

#### 修改了着色器中的功率计算

**文件**: `Source/RenderPasses/IncomingLightPowerPass/IncomingLightPowerPass.cs.slang` (第376行)

**原来的计算**:
```hlsl
// Calculate pixel area
pixelArea = computePixelArea(dimensions);

// Calculate power using the formula: Power = Radiance * Area * cos(θ)
float3 power = safeRadiance * pixelArea * cosTheta;
```

**修改后的计算**:
```hlsl
// Calculate total sensor area (now returns photosensitive plane area)
float totalSensorArea = computePixelArea(dimensions);

// Calculate effective area per pixel (distribute total area among all pixels)
uint totalPixels = dimensions.x * dimensions.y;
float effectiveAreaPerPixel = totalSensorArea / float(totalPixels);

// Calculate power using the formula: Power = Radiance * EffectiveArea * cos(θ)
// where EffectiveArea is the portion of photosensitive plane area assigned to this pixel
float3 power = safeRadiance * effectiveAreaPerPixel * cosTheta;
```

### 3. UI 和注释更新

#### 更新了头文件注释

**文件**: `Source/RenderPasses/IncomingLightPowerPass/IncomingLightPowerPass.h` (第181行)

```cpp
// 原来:
float mPixelAreaScale = 1.0f;     ///< Scale factor for pixel area calculation

// 修改后:
float mPixelAreaScale = 1.0f;     ///< Scale factor for photosensitive plane area calculation
```

#### 更新了 UI 控件文本

**文件**: `Source/RenderPasses/IncomingLightPowerPass/IncomingLightPowerPass.cpp` (第795行)

```cpp
// 原来:
auto pixelAreaGroup = widget.group("Pixel Area Adjustment", true);
changed |= widget.slider("Pixel Area Scale", mPixelAreaScale, 1.0f, 10000.0f);
widget.tooltip("Scales the calculated pixel area to make power values more visible.");

// 修改后:
auto areaGroup = widget.group("Photosensitive Plane Area Adjustment", true);
changed |= widget.slider("Area Scale Factor", mPixelAreaScale, 1.0f, 10000.0f);
widget.tooltip("Scales the calculated photosensitive plane area to adjust power values.\nNow uses physical sensor area instead of individual pixel area.");
```

## 遇到的错误和修复

### 1. 计算公式错误
**错误**: 在修改 SLANG 着色器时，最初写成了 `sensorWidth * sensorWidth`
**修复**: 改为正确的 `sensorWidth * sensorHeight`

### 2. 光电探测器分析支持
**解决方案**: 在 SLANG 着色器中添加了对光电探测器分析的特殊处理，当启用光电探测器分析时，直接使用 `gDetectorArea` 作为物理面积。

## 异常处理

### 1. 最小面积保护
```cpp
// C++ 代码中
const float minSensorArea = 0.001f;
totalSensorArea = std::max(totalSensorArea, minSensorArea);
```

### 2. 除零保护
```cpp
// 计算每像素有效面积时
uint32_t totalPixels = mFrameDimensions.x * mFrameDimensions.y;
float effectiveAreaPerPixel = totalSensorArea / totalPixels;
```

确保 `totalPixels` 不为零，因为 `mFrameDimensions` 在初始化时已经设置了合理的值。

### 3. 向后兼容性
保持了 `pixelArea` 变量名在某些地方的使用，以确保调试代码的兼容性，但其实际含义已经改为"每像素的有效面积"。

## 物理意义改进

### 修改前的问题
- 使用单个像素的几何面积进行功率计算
- 没有考虑整个感光平面的物理特性
- 功率计算在物理上不够准确

### 修改后的优势
- 使用整个感光平面的物理面积
- 将总面积按像素数量平均分配
- 支持光电探测器的直接物理面积使用
- 功率计算更符合光学原理

## 总结

通过这次修改，将功率测量从不正确的像素面积计算改为正确的感光平面物理面积计算，提高了功率测量的物理准确性。修改涉及了 C++ 代码、SLANG 着色器代码、UI 文本和相关注释，确保了代码的一致性和可维护性。 