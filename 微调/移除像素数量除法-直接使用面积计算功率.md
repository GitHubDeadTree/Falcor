# 移除像素数量除法：直接使用面积计算功率

## 修改概述

### 问题描述
之前的实现中，无论是光电探测器模式还是相机模式，都在进行以下计算：
1. 获取总面积（`gDetectorArea` 或计算的传感器面积）
2. 将总面积除以像素数量，得到"每像素有效面积"
3. 使用这个"每像素有效面积"计算功率

这种做法在物理上是有问题的，因为：
- **光电探测器**：应该使用整个探测器的物理面积
- **相机传感器**：应该使用整个传感器面积或其他合理的面积值

### 解决方案
移除像素数量的除法操作，直接使用面积值进行功率计算。

## 实现的修改

### 1. SLANG 着色器修改

#### 修改功率计算逻辑

**文件**: `Source/RenderPasses/IncomingLightPowerPass/IncomingLightPowerPass.cs.slang`

**原来的实现** (第377-383行):
```hlsl
// Calculate total sensor area (now returns photosensitive plane area)
float totalSensorArea = computePixelArea(dimensions);

// Calculate effective area per pixel (distribute total area among all pixels)
uint totalPixels = dimensions.x * dimensions.y;
float effectiveAreaPerPixel = totalSensorArea / float(totalPixels);
pixelArea = effectiveAreaPerPixel; // For backward compatibility with debug code
```

**修改后的实现**:
```hlsl
// Calculate area directly without dividing by pixel count
float area = computePixelArea(dimensions);
pixelArea = area; // For backward compatibility with debug code
```

#### 修改功率计算公式

**原来的计算**:
```hlsl
// Calculate power using the formula: Power = Radiance * EffectiveArea * cos(θ)
// where EffectiveArea is the portion of photosensitive plane area assigned to this pixel
float3 power = safeRadiance * effectiveAreaPerPixel * cosTheta;
```

**修改后的计算**:
```hlsl
// Calculate power using the formula: Power = Radiance * Area * cos(θ)
// Use the full area directly without dividing by pixel count
float3 power = safeRadiance * area * cosTheta;
```

#### 更新调试代码

**调试计算详情**:
```hlsl
// 原来:
gDebugCalculation[pixel] = float4(
    cosThetaDebug.dotProduct,           // Raw dot product
    cosThetaDebug.cosTheta,             // Before min clamp
    cosTheta,                           // Final value (after min clamp)
    effectiveAreaPerPixel               // Effective area per pixel for power calculation
);

// 修改后:
gDebugCalculation[pixel] = float4(
    cosThetaDebug.dotProduct,           // Raw dot product
    cosThetaDebug.cosTheta,             // Before min clamp
    cosTheta,                           // Final value (after min clamp)
    area                                // Area used for power calculation
);
```

**调试功率计算**:
```hlsl
// 原来:
float rPower = safeRadiance.r * effectiveAreaPerPixel * cosTheta;
float gPower = safeRadiance.g * effectiveAreaPerPixel * cosTheta;
float bPower = safeRadiance.b * effectiveAreaPerPixel * cosTheta;

// 修改后:
float rPower = safeRadiance.r * area * cosTheta;
float gPower = safeRadiance.g * area * cosTheta;
float bPower = safeRadiance.b * area * cosTheta;
```

### 2. C++ 代码修改

#### 修改功率计算逻辑

**文件**: `Source/RenderPasses/IncomingLightPowerPass/IncomingLightPowerPass.cpp` (第255-267行)

**原来的实现**:
```cpp
// Calculate sensor area (now returns total photosensitive plane area)
float totalSensorArea = computePixelArea();

// Calculate effective area per pixel (distribute total area among all pixels)
uint32_t totalPixels = mFrameDimensions.x * mFrameDimensions.y;
float effectiveAreaPerPixel = totalSensorArea / totalPixels;

// Calculate cosine term
float cosTheta = computeCosTheta(rayDir);

// Calculate power using the formula: Power = Radiance * EffectiveArea * cos(θ)
// where EffectiveArea is the portion of photosensitive plane area assigned to this pixel
float3 power = float3(radiance.r, radiance.g, radiance.b) * effectiveAreaPerPixel * cosTheta;
```

**修改后的实现**:
```cpp
// Calculate area directly without dividing by pixel count
float area = computePixelArea();

// Calculate cosine term
float cosTheta = computeCosTheta(rayDir);

// Calculate power using the formula: Power = Radiance * Area * cos(θ)
// Use the full area directly without dividing by pixel count
float3 power = float3(radiance.r, radiance.g, radiance.b) * area * cosTheta;
```

### 3. 注释和UI更新

#### 更新头文件注释

**文件**: `Source/RenderPasses/IncomingLightPowerPass/IncomingLightPowerPass.h` (第181行)

```cpp
// 原来:
float mPixelAreaScale = 1.0f;     ///< Scale factor for photosensitive plane area calculation

// 修改后:
float mPixelAreaScale = 1.0f;     ///< Scale factor for area calculation (no pixel division)
```

#### 更新UI控件和说明

**文件**: `Source/RenderPasses/IncomingLightPowerPass/IncomingLightPowerPass.cpp` (第796-802行)

```cpp
// 原来:
auto areaGroup = widget.group("Photosensitive Plane Area Adjustment", true);
changed |= widget.slider("Area Scale Factor", mPixelAreaScale, 1.0f, 10000.0f);
widget.tooltip("Scales the calculated photosensitive plane area to adjust power values.\nNow uses physical sensor area instead of individual pixel area.");

// 修改后:
auto areaGroup = widget.group("Area Scale Control", true);
changed |= widget.slider("Area Scale Factor", mPixelAreaScale, 1.0f, 10000.0f);
widget.tooltip("Scales the area used for power calculation.\nArea is used directly without dividing by pixel count.\nFor PD mode: scales gDetectorArea. For camera mode: scales computed sensor area.");
```

#### 更新函数注释

**文件**: `Source/RenderPasses/IncomingLightPowerPass/IncomingLightPowerPass.cs.slang` (第229行)

```hlsl
// 原来:
// Compute photosensitive plane physical area for power measurement

// 修改后:
// Compute area for power measurement (used directly, not divided by pixel count)
```

## 修改后的行为

### 光电探测器模式
- **面积使用**：直接使用 `gDetectorArea`（如 1e-6 m²）
- **功率计算**：`Power = Radiance * gDetectorArea * cos(θ)`
- **物理意义**：每个像素都使用整个探测器的面积进行计算

### 相机模式
- **面积使用**：直接使用计算的传感器面积 `sensorWidth * sensorHeight * gPixelAreaScale`
- **功率计算**：`Power = Radiance * 传感器面积 * cos(θ)`
- **物理意义**：每个像素都使用整个传感器的面积进行计算

## 影响和考虑

### 数值变化
- **功率值会显著增大**：因为不再除以像素数量
- **需要调整缩放因子**：可能需要调整 `mPixelAreaScale` 来获得合适的可视化效果

### 物理意义
- **更一致的逻辑**：消除了面积分配的概念问题
- **与光电探测器特殊分析对齐**：现在主要计算流程与光电探测器特殊分析使用相同的面积概念

### 潜在问题
- **所有像素使用相同面积**：这在某些应用场景下可能不合适
- **需要重新评估结果**：之前基于"每像素面积"的结果现在需要重新解释

## 总结

通过移除像素数量的除法操作，消除了面积计算中的逻辑不一致问题。现在两种模式都直接使用面积值进行功率计算，提供了更清晰和一致的物理模型。

这个修改简化了计算逻辑，但也改变了输出的数值范围，需要在后续使用中考虑这个变化的影响。 