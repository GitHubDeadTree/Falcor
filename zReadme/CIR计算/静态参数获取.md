我将仔细分析CIR计算方案中需要的6个静态参数，并实现相应的代码修改。让我首先搜索现有的CIR数据相关代码。
Search files...
Ran tool
Ran tool
Read file:
Read file: Source/RenderPasses/PathTracer/CIRPathData.slang
Read file: Source/Falcor/Rendering/Utils/PixelStats.h
现在让我搜索相机相关的参数获取代码：
Search files...
现在我对当前的CIR系统有了全面的了解。接下来我需要修改代码来添加6个静态参数。让我制定修改方案：

## 修改方案

我需要在CIR数据导出时添加6个静态参数：

1. **A** - 接收器有效面积（平方米）：通过相机感光平面计算
2. **m** - LED朗伯阶数：通过点光源参数计算
3. **c** - 光传播速度（常数 3×10⁸ m/s）
4. **FOV** - 接收器视场角：从相机参数获取
5. **T_s(θ)** - 光学滤波器透过率（设为1）
6. **g(θ)** - 光学集中增益（设为1）

### 主要修改内容：

1. 扩展CIR数据结构，添加静态参数字段
2. 在PixelStats中添加计算和获取这些参数的方法
3. 修改导出功能，在文件头部包含这6个参数

现在执行代码修改：
Read file: Source/Falcor/Rendering/Utils/PixelStats.cpp
现在我需要添加计算静态参数的方法。首先，我需要修改PixelStats.h来添加静态参数的结构：
Read file: Source/Falcor/Rendering/Utils/PixelStats.h
现在让我搜索Scene相关的代码，看如何获取场景和相机信息：
Search files...
好的，现在我有了足够的信息。我需要搜索PathTracer中如何访问Scene和Camera的信息：
Search files...
现在我有了足够的信息。我需要修改PixelStats类来添加CIR静态参数的计算和导出功能。让我开始修改代码：
Read file: Source/Falcor/Rendering/Utils/PixelStats.h
现在我开始修改代码。首先我需要添加静态参数结构和相关方法到PixelStats.h：
Read file: Source/Falcor/Rendering/Utils/PixelStats.h
现在我需要修改PixelStats.h，添加前向声明和CIR静态参数结构：

```cpp:Source/Falcor/Rendering/Utils/PixelStats.h
/***************************************************************************
 # Copyright (c) 2015-23, NVIDIA CORPORATION. All rights reserved.
 #
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions
 # are met:
 #  * Redistributions of source code must retain the above copyright
 #    notice, this list of conditions and the following disclaimer.
 #  * Redistributions in binary form must reproduce the above copyright
 #    notice, this list of conditions and the following disclaimer in the
 #    documentation and/or other materials provided with the distribution.
 #  * Neither the name of NVIDIA CORPORATION nor the names of its
 #    contributors may be used to endorse or promote products derived
 #    from this software without specific prior written permission.
 #
 # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS "AS IS" AND ANY
 # EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 # PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 # CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 # EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 # PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 **************************************************************************/
#pragma once
#include "PixelStatsShared.slang"
#include "Core/Macros.h"
#include "Core/API/Buffer.h"
#include "Core/API/Texture.h"
#include "Core/API/Fence.h"
#include "Core/Pass/ComputePass.h"
#include "Utils/UI/Gui.h"
#include "Utils/Algorithm/ParallelReduction.h"
#include <memory>
#include <vector>
#include <string>

namespace Falcor
{
    // Forward declarations
    class Scene;
    class Camera;
    class Light;

    // Forward declaration for CIR path data structure
    struct CIRPathData
    {
        float pathLength;
        float emissionAngle;
        float receptionAngle;
        float reflectanceProduct;
        uint32_t reflectionCount;
        float emittedPower;
        uint32_t pixelX;
        uint32_t pixelY;
        uint32_t pathIndex;
      
        bool isValid() const
        {
            return pathLength > 0.01f && pathLength < 1000.0f &&
                   emissionAngle >= 0.0f && emissionAngle <= 3.14159f &&
                   receptionAngle >= 0.0f && receptionAngle <= 3.14159f &&
                   reflectanceProduct >= 0.0f && reflectanceProduct <= 1.0f &&
                   emittedPower > 0.0f;
        }
    };

    // CIR static parameters structure for VLC analysis
    struct CIRStaticParameters
    {
        float receiverArea;         // A: Receiver effective area (m²)
        float ledLambertianOrder;   // m: LED Lambertian order
        float lightSpeed;           // c: Light propagation speed (m/s)
        float receiverFOV;          // FOV: Receiver field of view (radians)
        float opticalFilterGain;    // T_s(θ): Optical filter transmittance
        float opticalConcentration; // g(θ): Optical concentration gain
      
        CIRStaticParameters()
            : receiverArea(0.0f)
            , ledLambertianOrder(1.0f)
            , lightSpeed(3.0e8f)
            , receiverFOV(0.0f)
            , opticalFilterGain(1.0f)
            , opticalConcentration(1.0f)
        {}
    };

    /** Helper class for collecting runtime stats in the path tracer.

        Per-pixel stats are logged in buffers on the GPU, which are immediately ready for consumption
        after end() is called. These stats are summarized in a reduction pass, which are
        available in getStats() or printStats() after async readback to the CPU.
      
        Extended to support both statistical aggregation and raw CIR path data collection.
    */
    class FALCOR_API PixelStats
    {
    public:
        using CollectionMode = PixelStatsCollectionMode;

        struct Stats
        {
            uint32_t visibilityRays = 0;
            uint32_t closestHitRays = 0;
            uint32_t totalRays = 0;
            uint32_t pathVertices = 0;
            uint32_t volumeLookups = 0;
            float    avgVisibilityRays = 0.f;
            float    avgClosestHitRays = 0.f;
            float    avgTotalRays = 0.f;
            float    avgPathLength = 0.f;
            float    avgPathVertices = 0.f;
            float    avgVolumeLookups = 0.f;
          
            // CIR statistics
            uint32_t validCIRSamples = 0;
            float    avgCIRPathLength = 0.f;
            float    avgCIREmissionAngle = 0.f;
            float    avgCIRReceptionAngle = 0.f;
            float    avgCIRReflectanceProduct = 0.f;
            float    avgCIREmittedPower = 0.f;
            float    avgCIRReflectionCount = 0.f;
        };

        PixelStats(ref<Device> pDevice);

        void setEnabled(bool enabled) { mEnabled = enabled; }
        bool isEnabled() const { return mEnabled; }

        // Collection mode configuration
        void setCollectionMode(CollectionMode mode) { mCollectionMode = mode; }
        CollectionMode getCollectionMode() const { return mCollectionMode; }
      
        // CIR raw data configuration
        void setMaxCIRPathsPerFrame(uint32_t maxPaths) { mMaxCIRPathsPerFrame = maxPaths; }
        uint32_t getMaxCIRPathsPerFrame() const { return mMaxCIRPathsPerFrame; }

        void beginFrame(RenderContext* pRenderContext, const uint2& frameDim);
        void endFrame(RenderContext* pRenderContext);

        /** Perform program specialization and bind resources.
            This call doesn't change any resource declarations in the program.
        */
        void prepareProgram(const ref<Program>& pProgram, const ShaderVar& var);

        void renderUI(Gui::Widgets& widget);

        /** Fetches the latest stats generated by begin()/end().
            \param[out] stats The stats are copied here.
            \return True if stats are available, false otherwise.
        */
        bool getStats(PixelStats::Stats& stats);

        /** Returns the per-pixel ray count texture or nullptr if not available.
            \param[in] pRenderContext The render context.
            \return Texture in R32Uint format containing per-pixel ray counts, or nullptr if not available.
        */
        const ref<Texture> getRayCountTexture(RenderContext* pRenderContext);

        /** Returns the per-pixel path length texture or nullptr if not available.
            \return Texture in R32Uint format containing per-pixel path length, or nullptr if not available.
        */
        const ref<Texture> getPathLengthTexture() const;

        /** Returns the per-pixel path vertex count texture or nullptr if not available.
            \return Texture in R32Uint format containing per-pixel path vertex counts, or nullptr if not available.
        */
        const ref<Texture> getPathVertexCountTexture() const;

        /** Returns the per-pixel volume lookup count texture or nullptr if not available.
            \return Texture in R32Uint format containing per-pixel volume lookup counts, or nullptr if not available.
        */
        const ref<Texture> getVolumeLookupCountTexture() const;

        // CIR raw data access methods
        /** Get raw CIR path data collected in the last frame.
            Only available if collection mode includes RawData.
            \param[out] outData Vector to receive the CIR path data.
            \return True if data is available, false otherwise.
        */
        bool getCIRRawData(std::vector<CIRPathData>& outData);
      
        /** Get the number of CIR paths collected in the last frame.
            \return Number of paths collected, or 0 if no data available.
        */
        uint32_t getCIRPathCount();
      
        /** Export CIR raw data to a file with static parameters.
            \param[in] filename Output filename for the CIR data.
            \param[in] pScene Scene pointer for parameter calculation.
            \return True if export was successful, false otherwise.
        */
        bool exportCIRData(const std::string& filename, const ref<Scene>& pScene = nullptr);

        /** Compute CIR static parameters from scene information.
            \param[in] pScene Scene containing camera and light information.
            \param[in] frameDim Frame dimensions for area calculation.
            \return Computed static parameters structure.
        */
        CIRStaticParameters computeCIRStaticParameters(const ref<Scene>& pScene, const uint2& frameDim);

    protected:
        void copyStatsToCPU();
        void copyCIRRawDataToCPU();
        void computeRayCountTexture(RenderContext* pRenderContext);

        // Helper methods for static parameter computation
        float computeReceiverArea(const ref<Camera>& pCamera, const uint2& frameDim);
        float computeLEDLambertianOrder(const ref<Scene>& pScene);
        float computeReceiverFOV(const ref<Camera>& pCamera);

        static const uint32_t kRayTypeCount = (uint32_t)PixelStatsRayType::Count;
        static const uint32_t kCIRTypeCount = (uint32_t)PixelStatsCIRType::Count;

        ref<Device>                         mpDevice;

        // Internal state
        std::unique_ptr<ParallelReduction>  mpParallelReduction;            ///< Helper for parallel reduction on the GPU.
        ref<Buffer>                         mpReductionResult;              ///< Results buffer for stats readback (CPU mappable).
        ref<Fence>                          mpFence;                        ///< GPU fence for sychronizing readback.

        // Configuration
        bool                                mEnabled = false;               ///< Enable pixel statistics.
        bool                                mEnableLogging = false;         ///< Enable printing to logfile.
        CollectionMode                      mCollectionMode = CollectionMode::Both;  ///< Data collection mode.
        uint32_t                            mMaxCIRPathsPerFrame = 1000000; ///< Maximum CIR paths to collect per frame.

        // Runtime data
        bool                                mRunning = false;               ///< True inbetween begin() / end() calls.
        bool                                mWaitingForData = false;        ///< True if we are waiting for data to become available on the GPU.
        uint2                               mFrameDim = { 0, 0 };           ///< Frame dimensions at last call to begin().

        bool                                mStatsValid = false;            ///< True if stats have been read back and are valid.
        bool                                mRayCountTextureValid = false;  ///< True if total ray count texture is valid.
        Stats                               mStats;                         ///< Traversal stats.

        ref<Texture>                        mpStatsRayCount[kRayTypeCount]; ///< Buffers for per-pixel ray count stats.
        ref<Texture>                        mpStatsRayCountTotal;           ///< Buffer for per-pixel total ray count. Only generated if getRayCountTexture() is called.
        ref<Texture>                        mpStatsPathLength;              ///< Buffer for per-pixel path length stats.
        ref<Texture>                        mpStatsPathVertexCount;         ///< Buffer for per-pixel path vertex count.
        ref<Texture>                        mpStatsVolumeLookupCount;       ///< Buffer for per-pixel volume lookup count.
        bool                                mStatsBuffersValid = false;     ///< True if per-pixel stats buffers contain valid data.

        // CIR statistics buffers
        ref<Texture>                        mpStatsCIRData[kCIRTypeCount];  ///< Buffers for per-pixel CIR data stats.
        ref<Texture>                        mpStatsCIRValidSamples;         ///< Buffer for per-pixel valid CIR sample count.

        // CIR raw data collection buffers
        ref<Buffer>                         mpCIRRawDataBuffer;             ///< GPU buffer for raw CIR path data.
        ref<Buffer>                         mpCIRCounterBuffer;             ///< GPU buffer for path counter.
        ref<Buffer>                         mpCIRRawDataReadback;           ///< CPU-readable buffer for CIR raw data.
        ref<Buffer>                         mpCIRCounterReadback;           ///< CPU-readable buffer for path counter.
        bool                                mCIRRawDataValid = false;       ///< True if raw CIR data is valid.
        uint32_t                            mCollectedCIRPaths = 0;         ///< Number of CIR paths collected in last frame.
        std::vector<CIRPathData>            mCIRRawData;                    ///< CPU copy of raw CIR data.

        ref<ComputePass>                    mpComputeRayCount;              ///< Pass for computing per-pixel total ray count.
    };
}

```

现在我需要修改PixelStats.cpp，添加必要的头文件和实现静态参数计算方法：
Read file: Source/Falcor/Rendering/Utils/PixelStats.cpp
现在我需要修改PixelStats.cpp，添加必要的头文件并实现新的方法。让我先修改头文件部分和添加新的实现：

```cpp:Source/Falcor/Rendering/Utils/PixelStats.cpp
/***************************************************************************
 # Copyright (c) 2015-23, NVIDIA CORPORATION. All rights reserved.
 #
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions
 # are met:
 #  * Redistributions of source code must retain the above copyright
 #    notice, this list of conditions and the following disclaimer.
 #  * Redistributions in binary form must reproduce the above copyright
 #    notice, this list of conditions and the following disclaimer in the
 #    documentation and/or other materials provided with the distribution.
 #  * Neither the name of NVIDIA CORPORATION nor the names of its
 #    contributors may be used to endorse or promote products derived
 #    from this software without specific prior written permission.
 #
 # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS "AS IS" AND ANY
 # EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 # PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 # CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 # EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 # PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 **************************************************************************/
#include "PixelStats.h"
#include "Core/API/RenderContext.h"
#include "Scene/Scene.h"
#include "Scene/Camera/Camera.h"
#include "Scene/Lights/Light.h"
#include "Utils/Math/FalcorMath.h"
#include "Utils/Logger.h"
#include "Utils/Scripting/ScriptBindings.h"
#include <sstream>
#include <iomanip>
#include <fstream>
#include <algorithm>
#include <cmath>

namespace Falcor
{
    namespace
    {
        const char kComputeRayCountFilename[] = "Rendering/Utils/PixelStats.cs.slang";

        pybind11::dict toPython(const PixelStats::Stats& stats)
        {
            pybind11::dict d;
            d["visibilityRays"] = stats.visibilityRays;
            d["closestHitRays"] = stats.closestHitRays;
            d["totalRays"] = stats.totalRays;
            d["pathVertices"] = stats.pathVertices;
            d["volumeLookups"] = stats.volumeLookups;
            d["avgVisibilityRays"] = stats.avgVisibilityRays;
            d["avgClosestHitRays"] = stats.avgClosestHitRays;
            d["avgTotalRays"] = stats.avgTotalRays;
            d["avgPathLength"] = stats.avgPathLength;
            d["avgPathVertices"] = stats.avgPathVertices;
            d["avgVolumeLookups"] = stats.avgVolumeLookups;
            return d;
        }
    }

    PixelStats::PixelStats(ref<Device> pDevice)
        : mpDevice(pDevice)
    {
        mpComputeRayCount = ComputePass::create(mpDevice, kComputeRayCountFilename, "main");
    }

    // ... existing code ...

    float PixelStats::computeReceiverArea(const ref<Camera>& pCamera, const uint2& frameDim)
    {
        if (!pCamera) return 1e-4f; // Default 1 cm²

        try
        {
            // Get camera parameters for calculating sensor area
            float focalLength = pCamera->getFocalLength(); // mm
            float frameHeight = pCamera->getFrameHeight(); // mm
            float aspectRatio = pCamera->getAspectRatio();

            // Calculate FOV from focal length and frame height
            float fovY = focalLengthToFovY(focalLength, frameHeight); // radians
          
            // Calculate physical sensor dimensions in meters
            float sensorHeightM = frameHeight * 1e-3f; // Convert mm to meters
            float sensorWidthM = sensorHeightM * aspectRatio;
          
            // Calculate total sensor area
            float totalSensorArea = sensorWidthM * sensorHeightM; // m²
          
            // Calculate pixel area (total sensor area divided by number of pixels)
            uint32_t totalPixels = frameDim.x * frameDim.y;
            float pixelArea = totalSensorArea / totalPixels;
          
            logInfo("PixelStats: Computed receiver area = {:.6e} m² (total sensor: {:.6e} m², pixels: {})",
                   pixelArea, totalSensorArea, totalPixels);
                 
            return pixelArea;
        }
        catch (const std::exception& e)
        {
            logError("PixelStats: Error computing receiver area: {}", e.what());
            return 1e-4f; // Default fallback
        }
    }

    float PixelStats::computeLEDLambertianOrder(const ref<Scene>& pScene)
    {
        if (!pScene) return 1.0f; // Default Lambertian order

        try
        {
            const auto& lights = pScene->getLights();
            if (lights.empty())
            {
                logWarning("PixelStats: No lights found in scene, using default Lambertian order = 1.0");
                return 1.0f;
            }

            // Find first point light and calculate Lambertian order
            for (const auto& pLight : lights)
            {
                if (pLight->getType() == LightType::Point)
                {
                    const auto* pPointLight = static_cast<const PointLight*>(pLight.get());
                    float openingAngle = pPointLight->getOpeningAngle(); // radians
                  
                    // Calculate Lambertian order using m = -ln(2)/ln(cos(θ_1/2))
                    if (openingAngle >= (float)M_PI)
                    {
                        // Isotropic light source: m = 1 (Lambertian)
                        logInfo("PixelStats: Found isotropic point light, Lambertian order = 1.0");
                        return 1.0f;
                    }
                    else
                    {
                        float halfAngle = openingAngle * 0.5f;
                        float cosHalfAngle = std::cos(halfAngle);
                      
                        if (cosHalfAngle > 0.0f && cosHalfAngle < 1.0f)
                        {
                            float lambertianOrder = -std::log(2.0f) / std::log(cosHalfAngle);
                            logInfo("PixelStats: Computed LED Lambertian order = {:.3f} (half-angle = {:.3f} rad)",
                                   lambertianOrder, halfAngle);
                            return std::max(0.1f, lambertianOrder); // Ensure positive value
                        }
                    }
                }
            }
          
            logWarning("PixelStats: No suitable point light found, using default Lambertian order = 1.0");
            return 1.0f;
        }
        catch (const std::exception& e)
        {
            logError("PixelStats: Error computing LED Lambertian order: {}", e.what());
            return 1.0f; // Default fallback
        }
    }

    float PixelStats::computeReceiverFOV(const ref<Camera>& pCamera)
    {
        if (!pCamera) return (float)M_PI; // Default wide FOV

        try
        {
            float focalLength = pCamera->getFocalLength(); // mm
            float frameHeight = pCamera->getFrameHeight(); // mm
          
            // Calculate vertical FOV
            float fovY = focalLengthToFovY(focalLength, frameHeight); // radians
          
            logInfo("PixelStats: Computed receiver FOV = {:.3f} rad ({:.1f} degrees)",
                   fovY, fovY * 180.0f / (float)M_PI);
                 
            return fovY;
        }
        catch (const std::exception& e)
        {
            logError("PixelStats: Error computing receiver FOV: {}", e.what());
            return (float)M_PI; // Default fallback
        }
    }

    CIRStaticParameters PixelStats::computeCIRStaticParameters(const ref<Scene>& pScene, const uint2& frameDim)
    {
        CIRStaticParameters params;
      
        if (!pScene)
        {
            logWarning("PixelStats: No scene provided, using default CIR static parameters");
            return params;
        }

        try
        {
            // Get camera for receiver calculations
            ref<Camera> pCamera = pScene->getCamera();
          
            if (pCamera)
            {
                // 1. Compute receiver effective area (A)
                params.receiverArea = computeReceiverArea(pCamera, frameDim);
              
                // 4. Compute receiver field of view (FOV)
                params.receiverFOV = computeReceiverFOV(pCamera);
            }
            else
            {
                logWarning("PixelStats: No camera found, using default receiver parameters");
                params.receiverArea = 1e-4f; // 1 cm²
                params.receiverFOV = (float)M_PI; // 180 degrees
            }
          
            // 2. Compute LED Lambertian order (m)
            params.ledLambertianOrder = computeLEDLambertianOrder(pScene);
          
            // 3. Light speed (c) - physical constant
            params.lightSpeed = 3.0e8f; // m/s
          
            // 5. Optical filter transmittance (T_s) - set to 1.0 (no filter)
            params.opticalFilterGain = 1.0f;
          
            // 6. Optical concentration gain (g) - set to 1.0 (no concentration)
            params.opticalConcentration = 1.0f;
          
            logInfo("PixelStats: Computed CIR static parameters:");
            logInfo("  Receiver area: {:.6e} m²", params.receiverArea);
            logInfo("  LED Lambertian order: {:.3f}", params.ledLambertianOrder);
            logInfo("  Light speed: {:.3e} m/s", params.lightSpeed);
            logInfo("  Receiver FOV: {:.3f} rad", params.receiverFOV);
            logInfo("  Optical filter gain: {:.1f}", params.opticalFilterGain);
            logInfo("  Optical concentration: {:.1f}", params.opticalConcentration);
          
            return params;
        }
        catch (const std::exception& e)
        {
            logError("PixelStats: Error computing CIR static parameters: {}", e.what());
            return CIRStaticParameters(); // Return default parameters
        }
    }

    uint32_t PixelStats::getCIRPathCount()
    {
        copyCIRRawDataToCPU();
        return mCIRRawDataValid ? static_cast<uint32_t>(mCIRRawData.size()) : 0;
    }

    bool PixelStats::exportCIRData(const std::string& filename, const ref<Scene>& pScene)
    {
        copyCIRRawDataToCPU();
        if (!mCIRRawDataValid || mCIRRawData.empty())
        {
            logWarning("PixelStats::exportCIRData() - No valid CIR data to export.");
            return false;
        }

        try
        {
            std::ofstream file(filename);
            if (!file.is_open())
            {
                logError(fmt::format("PixelStats::exportCIRData() - Failed to open file: {}", filename));
                return false;
            }

            // Compute static parameters if scene is provided
            CIRStaticParameters staticParams;
            if (pScene)
            {
                staticParams = computeCIRStaticParameters(pScene, mFrameDim);
            }

            // Write header with static parameters
            file << "# CIR Path Data Export with Static Parameters\n";
            file << "# Static Parameters for VLC Channel Impulse Response Calculation:\n";
            file << "# A_receiver_area_m2=" << std::scientific << std::setprecision(6) << staticParams.receiverArea << "\n";
            file << "# m_led_lambertian_order=" << std::fixed << std::setprecision(3) << staticParams.ledLambertianOrder << "\n";
            file << "# c_light_speed_ms=" << std::scientific << std::setprecision(3) << staticParams.lightSpeed << "\n";
            file << "# FOV_receiver_rad=" << std::fixed << std::setprecision(3) << staticParams.receiverFOV << "\n";
            file << "# T_s_optical_filter_gain=" << std::fixed << std::setprecision(1) << staticParams.opticalFilterGain << "\n";
            file << "# g_optical_concentration=" << std::fixed << std::setprecision(1) << staticParams.opticalConcentration << "\n";
            file << "#\n";
            file << "# Path Data Format: PathIndex,PixelX,PixelY,PathLength(m),EmissionAngle(rad),ReceptionAngle(rad),ReflectanceProduct,ReflectionCount,EmittedPower(W)\n";
            file << std::fixed << std::setprecision(6);

            // Write path data
            for (size_t i = 0; i < mCIRRawData.size(); i++)
            {
                const auto& data = mCIRRawData[i];
                file << i << "," 
                     << data.pixelX << "," 
                     << data.pixelY << ","
                     << data.pathLength << ","
                     << data.emissionAngle << ","
                     << data.receptionAngle << ","
                     << data.reflectanceProduct << ","
                     << data.reflectionCount << ","
                     << data.emittedPower << "\n";
            }

            file.close();
            logInfo(fmt::format("PixelStats: Exported {} CIR paths with static parameters to {}", mCIRRawData.size(), filename));
            return true;
        }
        catch (const std::exception& e)
        {
            logError(fmt::format("PixelStats::exportCIRData() - Error writing file: {}", e.what()));
            return false;
        }
    }

    // ... rest of existing code remains unchanged ...
}
```

现在我需要修改PathTracer.cpp，使其在调用exportCIRData时传递Scene参数：
Search files...
我发现PixelStats有两个exportCIRData方法声明，一个有Scene参数，一个没有。我需要找到是谁在调用这个方法，然后修改调用处：
Ran tool
现在我看到exportCIRData在PixelStats.cpp的第299行被调用。让我查看这个调用的上下文：
Read file: Source/Falcor/Rendering/Utils/PixelStats.cpp
我发现exportCIRData在UI中被调用。这个调用在PixelStats的renderUI方法中。现在我需要找到是谁调用renderUI方法，以及是否可以传递Scene信息。我需要修改PixelStats类，使其可以存储Scene引用或在导出时提供Scene。

现在让我开始执行代码修改。首先，我会创建完整的修改：
Read file: Source/Falcor/Rendering/Utils/PixelStats.cpp
现在我了解了结构。我需要添加一个方法来设置Scene引用，然后修改UI调用。让我执行完整的代码修改：

```cpp:Source/Falcor/Rendering/Utils/PixelStats.h
/***************************************************************************
 # Copyright (c) 2015-23, NVIDIA CORPORATION. All rights reserved.
 #
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions
 # are met:
 #  * Redistributions of source code must retain the above copyright
 #    notice, this list of conditions and the following disclaimer.
 #  * Redistributions in binary form must reproduce the above copyright
 #    notice, this list of conditions and the following disclaimer in the
 #    documentation and/or other materials provided with the distribution.
 #  * Neither the name of NVIDIA CORPORATION nor the names of its
 #    contributors may be used to endorse or promote products derived
 #    from this software without specific prior written permission.
 #
 # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS "AS IS" AND ANY
 # EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 # PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 # CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 # EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 # PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 **************************************************************************/
#pragma once
#include "PixelStatsShared.slang"
#include "Core/Macros.h"
#include "Core/API/Buffer.h"
#include "Core/API/Texture.h"
#include "Core/API/Fence.h"
#include "Core/Pass/ComputePass.h"
#include "Utils/UI/Gui.h"
#include "Utils/Algorithm/ParallelReduction.h"
#include <memory>
#include <vector>
#include <string>

namespace Falcor
{
    // Forward declarations
    class Scene;
    class Camera;
    class Light;

    // Forward declaration for CIR path data structure
    struct CIRPathData
    {
        float pathLength;
        float emissionAngle;
        float receptionAngle;
        float reflectanceProduct;
        uint32_t reflectionCount;
        float emittedPower;
        uint32_t pixelX;
        uint32_t pixelY;
        uint32_t pathIndex;
      
        bool isValid() const
        {
            return pathLength > 0.01f && pathLength < 1000.0f &&
                   emissionAngle >= 0.0f && emissionAngle <= 3.14159f &&
                   receptionAngle >= 0.0f && receptionAngle <= 3.14159f &&
                   reflectanceProduct >= 0.0f && reflectanceProduct <= 1.0f &&
                   emittedPower > 0.0f;
        }
    };

    // CIR static parameters structure for VLC analysis
    struct CIRStaticParameters
    {
        float receiverArea;         // A: Receiver effective area (m²)
        float ledLambertianOrder;   // m: LED Lambertian order
        float lightSpeed;           // c: Light propagation speed (m/s)
        float receiverFOV;          // FOV: Receiver field of view (radians)
        float opticalFilterGain;    // T_s(θ): Optical filter transmittance
        float opticalConcentration; // g(θ): Optical concentration gain
      
        CIRStaticParameters()
            : receiverArea(0.0f)
            , ledLambertianOrder(1.0f)
            , lightSpeed(3.0e8f)
            , receiverFOV(0.0f)
            , opticalFilterGain(1.0f)
            , opticalConcentration(1.0f)
        {}
    };

    /** Helper class for collecting runtime stats in the path tracer.

        Per-pixel stats are logged in buffers on the GPU, which are immediately ready for consumption
        after end() is called. These stats are summarized in a reduction pass, which are
        available in getStats() or printStats() after async readback to the CPU.
      
        Extended to support both statistical aggregation and raw CIR path data collection.
    */
    class FALCOR_API PixelStats
    {
    public:
        using CollectionMode = PixelStatsCollectionMode;

        struct Stats
        {
            uint32_t visibilityRays = 0;
            uint32_t closestHitRays = 0;
            uint32_t totalRays = 0;
            uint32_t pathVertices = 0;
            uint32_t volumeLookups = 0;
            float    avgVisibilityRays = 0.f;
            float    avgClosestHitRays = 0.f;
            float    avgTotalRays = 0.f;
            float    avgPathLength = 0.f;
            float    avgPathVertices = 0.f;
            float    avgVolumeLookups = 0.f;
          
            // CIR statistics
            uint32_t validCIRSamples = 0;
            float    avgCIRPathLength = 0.f;
            float    avgCIREmissionAngle = 0.f;
            float    avgCIRReceptionAngle = 0.f;
            float    avgCIRReflectanceProduct = 0.f;
            float    avgCIREmittedPower = 0.f;
            float    avgCIRReflectionCount = 0.f;
        };

        PixelStats(ref<Device> pDevice);

        void setEnabled(bool enabled) { mEnabled = enabled; }
        bool isEnabled() const { return mEnabled; }

        // Collection mode configuration
        void setCollectionMode(CollectionMode mode) { mCollectionMode = mode; }
        CollectionMode getCollectionMode() const { return mCollectionMode; }
      
        // CIR raw data configuration
        void setMaxCIRPathsPerFrame(uint32_t maxPaths) { mMaxCIRPathsPerFrame = maxPaths; }
        uint32_t getMaxCIRPathsPerFrame() const { return mMaxCIRPathsPerFrame; }

        // Scene reference for CIR parameter calculation
        void setScene(const ref<Scene>& pScene) { mpScene = pScene; }

        void beginFrame(RenderContext* pRenderContext, const uint2& frameDim);
        void endFrame(RenderContext* pRenderContext);

        /** Perform program specialization and bind resources.
            This call doesn't change any resource declarations in the program.
        */
        void prepareProgram(const ref<Program>& pProgram, const ShaderVar& var);

        void renderUI(Gui::Widgets& widget);

        /** Fetches the latest stats generated by begin()/end().
            \param[out] stats The stats are copied here.
            \return True if stats are available, false otherwise.
        */
        bool getStats(PixelStats::Stats& stats);

        /** Returns the per-pixel ray count texture or nullptr if not available.
            \param[in] pRenderContext The render context.
            \return Texture in R32Uint format containing per-pixel ray counts, or nullptr if not available.
        */
        const ref<Texture> getRayCountTexture(RenderContext* pRenderContext);

        /** Returns the per-pixel path length texture or nullptr if not available.
            \return Texture in R32Uint format containing per-pixel path length, or nullptr if not available.
        */
        const ref<Texture> getPathLengthTexture() const;

        /** Returns the per-pixel path vertex count texture or nullptr if not available.
            \return Texture in R32Uint format containing per-pixel path vertex counts, or nullptr if not available.
        */
        const ref<Texture> getPathVertexCountTexture() const;

        /** Returns the per-pixel volume lookup count texture or nullptr if not available.
            \return Texture in R32Uint format containing per-pixel volume lookup counts, or nullptr if not available.
        */
        const ref<Texture> getVolumeLookupCountTexture() const;

        // CIR raw data access methods
        /** Get raw CIR path data collected in the last frame.
            Only available if collection mode includes RawData.
            \param[out] outData Vector to receive the CIR path data.
            \return True if data is available, false otherwise.
        */
        bool getCIRRawData(std::vector<CIRPathData>& outData);
      
        /** Get the number of CIR paths collected in the last frame.
            \return Number of paths collected, or 0 if no data available.
        */
        uint32_t getCIRPathCount();
      
        /** Export CIR raw data to a file with static parameters.
            \param[in] filename Output filename for the CIR data.
            \param[in] pScene Scene pointer for parameter calculation (optional, will use stored scene if null).
            \return True if export was successful, false otherwise.
        */
        bool exportCIRData(const std::string& filename, const ref<Scene>& pScene = nullptr);

        /** Compute CIR static parameters from scene information.
            \param[in] pScene Scene containing camera and light information.
            \param[in] frameDim Frame dimensions for area calculation.
            \return Computed static parameters structure.
        */
        CIRStaticParameters computeCIRStaticParameters(const ref<Scene>& pScene, const uint2& frameDim);

    protected:
        void copyStatsToCPU();
        void copyCIRRawDataToCPU();
        void computeRayCountTexture(RenderContext* pRenderContext);

        // Helper methods for static parameter computation
        float computeReceiverArea(const ref<Camera>& pCamera, const uint2& frameDim);
        float computeLEDLambertianOrder(const ref<Scene>& pScene);
        float computeReceiverFOV(const ref<Camera>& pCamera);

        static const uint32_t kRayTypeCount = (uint32_t)PixelStatsRayType::Count;
        static const uint32_t kCIRTypeCount = (uint32_t)PixelStatsCIRType::Count;

        ref<Device>                         mpDevice;

        // Internal state
        std::unique_ptr<ParallelReduction>  mpParallelReduction;            ///< Helper for parallel reduction on the GPU.
        ref<Buffer>                         mpReductionResult;              ///< Results buffer for stats readback (CPU mappable).
        ref<Fence>                          mpFence;                        ///< GPU fence for sychronizing readback.

        // Configuration
        bool                                mEnabled = false;               ///< Enable pixel statistics.
        bool                                mEnableLogging = false;         ///< Enable printing to logfile.
        CollectionMode                      mCollectionMode = CollectionMode::Both;  ///< Data collection mode.
        uint32_t                            mMaxCIRPathsPerFrame = 1000000; ///< Maximum CIR paths to collect per frame.

        // Scene reference for CIR parameter computation
        ref<Scene>                          mpScene;                        ///< Scene reference for static parameter calculation.

        // Runtime data
        bool                                mRunning = false;               ///< True inbetween begin() / end() calls.
        bool                                mWaitingForData = false;        ///< True if we are waiting for data to become available on the GPU.
        uint2                               mFrameDim = { 0, 0 };           ///< Frame dimensions at last call to begin().

        bool                                mStatsValid = false;            ///< True if stats have been read back and are valid.
        bool                                mRayCountTextureValid = false;  ///< True if total ray count texture is valid.
        Stats                               mStats;                         ///< Traversal stats.

        ref<Texture>                        mpStatsRayCount[kRayTypeCount]; ///< Buffers for per-pixel ray count stats.
        ref<Texture>                        mpStatsRayCountTotal;           ///< Buffer for per-pixel total ray count. Only generated if getRayCountTexture() is called.
        ref<Texture>                        mpStatsPathLength;              ///< Buffer for per-pixel path length stats.
        ref<Texture>                        mpStatsPathVertexCount;         ///< Buffer for per-pixel path vertex count.
        ref<Texture>                        mpStatsVolumeLookupCount;       ///< Buffer for per-pixel volume lookup count.
        bool                                mStatsBuffersValid = false;     ///< True if per-pixel stats buffers contain valid data.

        // CIR statistics buffers
        ref<Texture>                        mpStatsCIRData[kCIRTypeCount];  ///< Buffers for per-pixel CIR data stats.
        ref<Texture>                        mpStatsCIRValidSamples;         ///< Buffer for per-pixel valid CIR sample count.

        // CIR raw data collection buffers
        ref<Buffer>                         mpCIRRawDataBuffer;             ///< GPU buffer for raw CIR path data.
        ref<Buffer>                         mpCIRCounterBuffer;             ///< GPU buffer for path counter.
        ref<Buffer>                         mpCIRRawDataReadback;           ///< CPU-readable buffer for CIR raw data.
        ref<Buffer>                         mpCIRCounterReadback;           ///< CPU-readable buffer for path counter.
        bool                                mCIRRawDataValid = false;       ///< True if raw CIR data is valid.
        uint32_t                            mCollectedCIRPaths = 0;         ///< Number of CIR paths collected in last frame.
        std::vector<CIRPathData>            mCIRRawData;                    ///< CPU copy of raw CIR data.

        ref<ComputePass>                    mpComputeRayCount;              ///< Pass for computing per-pixel total ray count.
    };
}

```

现在修改PixelStats.cpp，更新UI中的exportCIRData调用并实现新的方法：

```cpp:Source/Falcor/Rendering/Utils/PixelStats.cpp
// ... existing code ...

void PixelStats::renderUI(Gui::Widgets& widget)
{
    // Configuration.
    widget.checkbox("Ray stats", mEnabled);
    widget.tooltip("Collects ray tracing traversal stats on the GPU.\nNote that this option slows down the performance.");

    // Collection mode selection
    if (mEnabled)
    {
        widget.text("Collection Mode:");
      
        // Create dropdown list for collection modes
        const Gui::DropdownList kCollectionModeList = {
            {(uint32_t)CollectionMode::Statistics, "Statistics"},
            {(uint32_t)CollectionMode::RawData, "Raw Data"},
            {(uint32_t)CollectionMode::Both, "Both"}
        };
      
        uint32_t mode = (uint32_t)mCollectionMode;
        if (widget.dropdown("Mode", kCollectionModeList, mode))
        {
            mCollectionMode = (CollectionMode)mode;
        }
      
        if (mCollectionMode == CollectionMode::RawData || mCollectionMode == CollectionMode::Both)
        {
            widget.var("Max CIR paths per frame", mMaxCIRPathsPerFrame, 1000u, 10000000u);
          
            // CIR raw data controls
            copyCIRRawDataToCPU();
            widget.text(fmt::format("Collected CIR paths: {}", mCollectedCIRPaths));
            if (widget.button("Export CIR Data"))
            {
                // Use stored scene reference for parameter calculation
                exportCIRData("cir_data.txt", mpScene);
            }
        }
    }

    // ... rest of existing code ...
}

float PixelStats::computeReceiverArea(const ref<Camera>& pCamera, const uint2& frameDim)
{
    if (!pCamera) return 1e-4f; // Default 1 cm²

    try
    {
        // Get camera parameters for calculating sensor area
        float focalLength = pCamera->getFocalLength(); // mm
        float frameHeight = pCamera->getFrameHeight(); // mm
        float aspectRatio = pCamera->getAspectRatio();

        // Calculate FOV from focal length and frame height
        float fovY = focalLengthToFovY(focalLength, frameHeight); // radians
      
        // Calculate physical sensor dimensions in meters
        float sensorHeightM = frameHeight * 1e-3f; // Convert mm to meters
        float sensorWidthM = sensorHeightM * aspectRatio;
      
        // Calculate total sensor area
        float totalSensorArea = sensorWidthM * sensorHeightM; // m²
      
        // Calculate pixel area (total sensor area divided by number of pixels)
        uint32_t totalPixels = frameDim.x * frameDim.y;
        float pixelArea = totalSensorArea / totalPixels;
      
        logInfo("PixelStats: Computed receiver area = {:.6e} m² (total sensor: {:.6e} m², pixels: {})",
               pixelArea, totalSensorArea, totalPixels);
             
        return pixelArea;
    }
    catch (const std::exception& e)
    {
        logError("PixelStats: Error computing receiver area: {}", e.what());
        return 1e-4f; // Default fallback
    }
}

float PixelStats::computeLEDLambertianOrder(const ref<Scene>& pScene)
{
    if (!pScene) return 1.0f; // Default Lambertian order

    try
    {
        const auto& lights = pScene->getLights();
        if (lights.empty())
        {
            logWarning("PixelStats: No lights found in scene, using default Lambertian order = 1.0");
            return 1.0f;
        }

        // Find first point light and calculate Lambertian order
        for (const auto& pLight : lights)
        {
            if (pLight->getType() == LightType::Point)
            {
                const auto* pPointLight = static_cast<const PointLight*>(pLight.get());
                float openingAngle = pPointLight->getOpeningAngle(); // radians
              
                // Calculate Lambertian order using m = -ln(2)/ln(cos(θ_1/2))
                if (openingAngle >= (float)M_PI)
                {
                    // Isotropic light source: m = 1 (Lambertian)
                    logInfo("PixelStats: Found isotropic point light, Lambertian order = 1.0");
                    return 1.0f;
                }
                else
                {
                    float halfAngle = openingAngle * 0.5f;
                    float cosHalfAngle = std::cos(halfAngle);
                  
                    if (cosHalfAngle > 0.0f && cosHalfAngle < 1.0f)
                    {
                        float lambertianOrder = -std::log(2.0f) / std::log(cosHalfAngle);
                        logInfo("PixelStats: Computed LED Lambertian order = {:.3f} (half-angle = {:.3f} rad)",
                               lambertianOrder, halfAngle);
                        return std::max(0.1f, lambertianOrder); // Ensure positive value
                    }
                }
            }
        }
      
        logWarning("PixelStats: No suitable point light found, using default Lambertian order = 1.0");
        return 1.0f;
    }
    catch (const std::exception& e)
    {
        logError("PixelStats: Error computing LED Lambertian order: {}", e.what());
        return 1.0f; // Default fallback
    }
}

float PixelStats::computeReceiverFOV(const ref<Camera>& pCamera)
{
    if (!pCamera) return (float)M_PI; // Default wide FOV

    try
    {
        float focalLength = pCamera->getFocalLength(); // mm
        float frameHeight = pCamera->getFrameHeight(); // mm
      
        // Calculate vertical FOV
        float fovY = focalLengthToFovY(focalLength, frameHeight); // radians
      
        logInfo("PixelStats: Computed receiver FOV = {:.3f} rad ({:.1f} degrees)",
               fovY, fovY * 180.0f / (float)M_PI);
             
        return fovY;
    }
    catch (const std::exception& e)
    {
        logError("PixelStats: Error computing receiver FOV: {}", e.what());
        return (float)M_PI; // Default fallback
    }
}

CIRStaticParameters PixelStats::computeCIRStaticParameters(const ref<Scene>& pScene, const uint2& frameDim)
{
    CIRStaticParameters params;
  
    if (!pScene)
    {
        logWarning("PixelStats: No scene provided, using default CIR static parameters");
        return params;
    }

    try
    {
        // Get camera for receiver calculations
        ref<Camera> pCamera = pScene->getCamera();
      
        if (pCamera)
        {
            // 1. Compute receiver effective area (A)
            params.receiverArea = computeReceiverArea(pCamera, frameDim);
          
            // 4. Compute receiver field of view (FOV)
            params.receiverFOV = computeReceiverFOV(pCamera);
        }
        else
        {
            logWarning("PixelStats: No camera found, using default receiver parameters");
            params.receiverArea = 1e-4f; // 1 cm²
            params.receiverFOV = (float)M_PI; // 180 degrees
        }
      
        // 2. Compute LED Lambertian order (m)
        params.ledLambertianOrder = computeLEDLambertianOrder(pScene);
      
        // 3. Light speed (c) - physical constant
        params.lightSpeed = 3.0e8f; // m/s
      
        // 5. Optical filter transmittance (T_s) - set to 1.0 (no filter)
        params.opticalFilterGain = 1.0f;
      
        // 6. Optical concentration gain (g) - set to 1.0 (no concentration)
        params.opticalConcentration = 1.0f;
      
        logInfo("PixelStats: Computed CIR static parameters:");
        logInfo("  Receiver area: {:.6e} m²", params.receiverArea);
        logInfo("  LED Lambertian order: {:.3f}", params.ledLambertianOrder);
        logInfo("  Light speed: {:.3e} m/s", params.lightSpeed);
        logInfo("  Receiver FOV: {:.3f} rad", params.receiverFOV);
        logInfo("  Optical filter gain: {:.1f}", params.opticalFilterGain);
        logInfo("  Optical concentration: {:.1f}", params.opticalConcentration);
      
        return params;
    }
    catch (const std::exception& e)
    {
        logError("PixelStats: Error computing CIR static parameters: {}", e.what());
        return CIRStaticParameters(); // Return default parameters
    }
}

bool PixelStats::exportCIRData(const std::string& filename, const ref<Scene>& pScene)
{
    copyCIRRawDataToCPU();
    if (!mCIRRawDataValid || mCIRRawData.empty())
    {
        logWarning("PixelStats::exportCIRData() - No valid CIR data to export.");
        return false;
    }

    try
    {
        std::ofstream file(filename);
        if (!file.is_open())
        {
            logError(fmt::format("PixelStats::exportCIRData() - Failed to open file: {}", filename));
            return false;
        }

        // Compute static parameters if scene is provided
        CIRStaticParameters staticParams;
        ref<Scene> sceneToUse = pScene ? pScene : mpScene;
        if (sceneToUse)
        {
            staticParams = computeCIRStaticParameters(sceneToUse, mFrameDim);
        }

        // Write header with static parameters
        file << "# CIR Path Data Export with Static Parameters\n";
        file << "# Static Parameters for VLC Channel Impulse Response Calculation:\n";
        file << "# A_receiver_area_m2=" << std::scientific << std::setprecision(6) << staticParams.receiverArea << "\n";
        file << "# m_led_lambertian_order=" << std::fixed << std::setprecision(3) << staticParams.ledLambertianOrder << "\n";
        file << "# c_light_speed_ms=" << std::scientific << std::setprecision(3) << staticParams.lightSpeed << "\n";
        file << "# FOV_receiver_rad=" << std::fixed << std::setprecision(3) << staticParams.receiverFOV << "\n";
        file << "# T_s_optical_filter_gain=" << std::fixed << std::setprecision(1) << staticParams.opticalFilterGain << "\n";
        file << "# g_optical_concentration=" << std::fixed << std::setprecision(1) << staticParams.opticalConcentration << "\n";
        file << "#\n";
        file << "# Path Data Format: PathIndex,PixelX,PixelY,PathLength(m),EmissionAngle(rad),ReceptionAngle(rad),ReflectanceProduct,ReflectionCount,EmittedPower(W)\n";
        file << std::fixed << std::setprecision(6);

        // Write path data
        for (size_t i = 0; i < mCIRRawData.size(); i++)
        {
            const auto& data = mCIRRawData[i];
            file << i << "," 
                 << data.pixelX << "," 
                 << data.pixelY << ","
                 << data.pathLength << ","
                 << data.emissionAngle << ","
                 << data.receptionAngle << ","
                 << data.reflectanceProduct << ","
                 << data.reflectionCount << ","
                 << data.emittedPower << "\n";
        }

        file.close();
        logInfo(fmt::format("PixelStats: Exported {} CIR paths with static parameters to {}", mCIRRawData.size(), filename));
        return true;
    }
    catch (const std::exception& e)
    {
        logError(fmt::format("PixelStats::exportCIRData() - Error writing file: {}", e.what()));
        return false;
    }
}

// ... rest of existing code ...
```

现在我需要找到PathTracer中调用PixelStats的地方，确保Scene引用被正确设置：
Search files...

根据之前的分析和实现，我已经为您完成了在Falcor中为CIR数据导出添加6个静态参数的完整解决方案。让我总结一下已实现的核心功能：

## 已实现的功能

### 1. 数据结构扩展

在 `PixelStats.h` 中添加了 `CIRStaticParameters` 结构体，包含6个VLC系统静态参数：

- 接收器面积 (A)
- LED朗伯阶数 (m)
- 光速 (c)
- 接收器视场角 (FOV)
- 光学滤波器透射率 (T_s)
- 光学集中增益 (g)

### 2. 参数计算方法

实现了自动计算功能：

- **接收器面积**: 从相机传感器尺寸计算
- **LED朗伯阶数**: 从点光源开角计算 m = -ln(2)/ln(cos(θ₁/₂))
- **接收器FOV**: 从相机焦距参数计算
- **物理常数**: 光速设为标准值 3×10⁸ m/s

### 3. 导出格式增强

修改了CIR数据导出格式，在文件头部添加静态参数注释，确保与现有路径数据兼容。

### 4. 集成点设计

通过 `setScene()` 方法允许PathTracer传递场景引用，实现参数的自动计算。

## 关键集成点

您现在需要在PathTracer中添加一行代码来完成集成：
Search files...
现在让我寻找PathTracer中具体的setScene实现：
Read file: Source/RenderPasses/PathTracer/PathTracer.cpp
完美！我找到了PathTracer的 `setScene`方法。现在我需要在这个方法中添加对 `mpPixelStats->setScene()`的调用。让我看看这个方法的完整实现：
Read file: Source/RenderPasses/PathTracer/PathTracer.cpp
现在我已经掌握了完整的实现方案。基于之前的分析和实现，您需要在PathTracer的 `setScene`方法中添加一行代码来完成最终的集成。这是整个VLC CIR静态参数功能的最后一个关键步骤。

## 完成集成的最后步骤

您需要在PathTracer的 `setScene`方法中添加一行代码，让PixelStats能够访问场景信息来计算静态参数：

```39:66:Source/RenderPasses/PathTracer/PathTracer.cpp
void PathTracer::setScene(RenderContext* pRenderContext, const ref<Scene>& pScene)
{
    mUpdateFlagsConnection = {};
    mUpdateFlags = IScene::UpdateFlags::None;

    mpScene = pScene;
    mParams.frameCount = 0;
    mParams.frameDim = {};
    mParams.screenTiles = {};

    // Need to recreate the RTXDI module when the scene changes.
    mpRTXDI = nullptr;

    resetPrograms();
    resetLighting();

    // Set scene reference for PixelStats to enable CIR static parameter calculation
    if (mpPixelStats)
    {
        mpPixelStats->setScene(pScene);
    }

    if (mpScene)
    {
        mUpdateFlagsConnection = mpScene->getUpdateFlagsSignal().connect([&](IScene::UpdateFlags flags) { mUpdateFlags |= flags; });

        if (pScene->hasGeometryType(Scene::GeometryType::Custom))
        {
            logWarning("PathTracer: This render pass does not support custom primitives.");
        }

        validateOptions();
    }
}
```

这样，当PathTracer加载新场景时，PixelStats就能自动获得场景引用，并能够计算所需的VLC静态参数。

## 功能总结

通过这个实现，您现在拥有了：

1. **完整的CIR数据**: 包含12个参数（6个路径参数 + 6个静态参数）
2. **自动参数计算**: 系统会自动从场景中计算静态参数
3. **增强的导出格式**: CIR文件包含清晰的参数说明和标准化格式
4. **最小侵入性**: 保持PathTracer核心渲染流程不变
5. **向后兼容**: 现有功能完全保持不变

这个解决方案实现了您最初要求的"在PathTracer中只收集必要的原始数据，复杂计算使用新的/修改的渲染通道"的设计理念，为VLC信道脉冲响应分析提供了完整的数据支持。
