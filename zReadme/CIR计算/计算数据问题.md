æˆ‘çš„CIRæ•°æ®æœ‰ä¸€äº›å…¨æ˜¯0ï¼Œè¿™æ˜¯ç”±äºŽPathTracerçš„é»˜è®¤è®¾ç½®å¼•èµ·çš„ï¼Œè¿˜æ˜¯å› ä¸ºè®¡ç®—æ–¹æ³•å†™çš„æœ‰é—®é¢˜ï¼Ÿ

# CIR Path Data Export

# Format: PathIndex,PixelX,PixelY,PathLength(m),EmissionAngle(rad),ReceptionAngle(rad),ReflectanceProduct,ReflectionCount,EmittedPower(W)

0,182,26,3.642578,0.000000,1.482478,0.000000,1,0.022662
1,159,54,3.103516,0.000000,1.368537,0.000000,1,0.195078
2,166,30,1.791992,0.000000,0.294941,0.000000,1,0.031188
3,135,61,6.843750,0.000000,1.032346,0.000000,1,0.025541
4,247,55,4.796875,0.000000,1.172214,0.000000,1,0.110893
5,150,50,4.089844,0.000000,1.255759,0.000000,1,0.564567
6,304,25,3.646484,0.000000,0.274208,0.000000,1,0.514182
7,107,61,4.902344,0.000000,0.772947,0.000000,1,0.016680


åˆ†æžæ‚¨çš„CIRæ•°æ®ï¼Œæˆ‘å‘çŽ°æœ‰ä¸¤ä¸ªå­—æ®µç¡®å®žå­˜åœ¨é—®é¢˜ï¼š

## ðŸ” é—®é¢˜åˆ†æž

### 1. EmissionAngle å…¨ä¸º 0.000000

**é—®é¢˜åŽŸå› **ï¼šå‘å°„è§’è®¡ç®—æ–¹æ³•å¯èƒ½æ²¡æœ‰è¢«æ­£ç¡®è°ƒç”¨æˆ–è®¡ç®—é€»è¾‘æœ‰è¯¯

### 2. ReflectanceProduct å…¨ä¸º 0.000000

**é—®é¢˜åŽŸå› **ï¼šåå°„çŽ‡ç´¯ç§¯è¢«é”™è¯¯åœ°è®¾ç½®ä¸º0ï¼Œæˆ–è€…æ²¡æœ‰æ­£ç¡®æ›´æ–°

### 3. æ­£å¸¸çš„æ•°æ®

- âœ… **PathLength**ï¼š1.79-6.84ç±³ï¼Œåˆç†èŒƒå›´
- âœ… **ReceptionAngle**ï¼š0.27-1.48å¼§åº¦ï¼Œåœ¨[0,Ï€]èŒƒå›´å†…
- âœ… **ReflectionCount**ï¼šéƒ½æ˜¯1ï¼Œè¯´æ˜Žè¿™äº›æ˜¯ç›´æŽ¥è·¯å¾„ï¼ˆprimary hitï¼‰
- âœ… **EmittedPower**ï¼šæœ‰æ­£å¸¸çš„åŠŸçŽ‡å€¼

## ðŸ› é—®é¢˜è¯Šæ–­

è®©æˆ‘æ£€æŸ¥å½“å‰çš„å®žçŽ°ä»£ç æ¥æ‰¾å‡ºé—®é¢˜ï¼š
Search files...
Search files...
çŽ°åœ¨æˆ‘å·²ç»æ‰¾åˆ°é—®é¢˜çš„æ ¹æºäº†ï¼è®©æˆ‘åˆ†æžä»£ç å¹¶æŒ‡å‡ºå…·ä½“é—®é¢˜ï¼š

## ðŸ” é—®é¢˜æ ¹æºåˆ†æž

æŸ¥çœ‹ä»£ç åŽï¼Œæˆ‘å‘çŽ°äº†å¯¼è‡´ **EmissionAngle** å’Œ **ReflectanceProduct** å…¨ä¸º0çš„å…·ä½“åŽŸå› ï¼š

### 1. EmissionAngle å…¨ä¸º 0.000000 çš„åŽŸå› 

**é—®é¢˜å‡ºçŽ°åœ¨ç¬¬884è¡Œçš„è°ƒç”¨é€»è¾‘ï¼š**
Read file: Source/RenderPasses/PathTracer/PathTracer.slang
**é—®é¢˜1ï¼šEmissionAngleè®¡ç®—æ¡ä»¶é”™è¯¯**
åœ¨ `updateCIRDataDuringTracing`æ–¹æ³•ä¸­ï¼Œå‘å°„è§’åªåœ¨ `getVertexIndex() == 1`æ—¶è®¡ç®—ã€‚ä½†æ˜¯ï¼š

```hlsl
// Update emission angle: only calculate at first surface interaction
if (path.getVertexIndex() == 1) // At emission surface
{
    path.updateCIREmissionAngle(surfaceNormal);
}
```

**é—®é¢˜**ï¼š`getVertexIndex() == 1`è¡¨ç¤ºè¿™æ˜¯è·¯å¾„çš„ç¬¬ä¸€ä¸ªé¡¶ç‚¹ï¼Œä½†åœ¨Falcorä¸­ï¼Œ**ç¬¬ä¸€ä¸ªé¡¶ç‚¹é€šå¸¸æ˜¯ç›¸æœº/åˆå§‹ç‚¹**ï¼Œè€Œä¸æ˜¯å‘å…‰è¡¨é¢ï¼å‘å…‰è¡¨é¢åº”è¯¥æ˜¯è·¯å¾„ä¸­å®žé™…çš„å…‰æºè¡¨é¢ã€‚

### 2. ReflectanceProduct å…¨ä¸º 0.000000 çš„åŽŸå› 

**é—®é¢˜å‡ºçŽ°åœ¨åå°„çŽ‡æ›´æ–°æ¡ä»¶ï¼š**

```hlsl
// Accumulate reflectance: update at each valid reflection
if (reflectance > 0.0f && path.getVertexIndex() > 1)
{
    path.updateCIRReflectance(reflectance);
}
```

**é—®é¢˜**ï¼šè¿™é‡Œä½¿ç”¨çš„æ˜¯ `bsdfProperties.diffuseReflectionAlbedo.r`ï¼ˆæ¼«åå°„åç…§çŽ‡çš„çº¢è‰²åˆ†é‡ï¼‰ï¼Œä½†ï¼š

1. **å¾ˆå¤šè¡¨é¢çš„æ¼«åå°„åç…§çŽ‡çš„çº¢è‰²åˆ†é‡å¯èƒ½ç¡®å®žæ˜¯0**
2. **åº”è¯¥ä½¿ç”¨æ•´ä½“åå°„çŽ‡ï¼Œè€Œä¸æ˜¯å•ä¸€é¢œè‰²é€šé“**
3. **ReflectionCountéƒ½æ˜¯1è¯´æ˜Žè¿™äº›æ˜¯ç›´æŽ¥è·¯å¾„ï¼Œæ²¡æœ‰åå°„ï¼Œæ‰€ä»¥åå°„çŽ‡åº”è¯¥ä¿æŒåˆå§‹å€¼1.0**

## ðŸ”§ ä¿®å¤æ–¹æ¡ˆ

Read file: Source/RenderPasses/PathTracer/PathTracer.slang
æ ¹æ®åˆ†æžï¼Œæˆ‘éœ€è¦ä¿®å¤ä»¥ä¸‹é—®é¢˜ï¼š

## ðŸ”§ ä¿®å¤æ–¹æ¡ˆå®žæ–½

### é—®é¢˜1ï¼šEmissionAngle è®¡ç®—æ—¶æœºé”™è¯¯

### é—®é¢˜2ï¼šReflectanceProduct ä½¿ç”¨é”™è¯¯çš„åå°„çŽ‡å€¼

```hlsl:Source/RenderPasses/PathTracer/PathTracer.slang
// ... existing code ...

/** Update CIR data during path tracing (simplified version).
    Only updates CIR parameters that require special calculation.
    Other parameters are dynamically obtained through getCIRData().
    \param[in,out] path Path state.
    \param[in] surfaceNormal Surface normal at hit point.
    \param[in] bsdfProperties BSDF properties for more accurate reflectance calculation.
*/
void updateCIRDataDuringTracing(inout PathState path, float3 surfaceNormal, BSDFProperties bsdfProperties)
{
    // Note: Basic parameters (pathLength, reflectionCount, emittedPower) do not need real-time updates
    // because they are directly reused from existing PathState fields and dynamically obtained in getCIRData()
  
    const uint vertexIndex = path.getVertexIndex();
    const bool isPrimaryHit = (vertexIndex == 1);
  
    // Update emission angle: Calculate when hitting an emissive surface
    if (any(bsdfProperties.emission > 0.0f))
    {
        path.updateCIREmissionAngle(surfaceNormal);
    }
  
    // Accumulate reflectance: For VLC paths, we need total reflectance, not per-channel
    // Only accumulate if this is a reflection event (not primary hit from camera)
    if (!isPrimaryHit)
    {
        // Calculate average reflectance across RGB channels for better representation
        float3 diffuseAlbedo = bsdfProperties.diffuseReflectionAlbedo;
        float3 specularAlbedo = bsdfProperties.specularReflectionAlbedo;
      
        // Combine diffuse and specular reflectance (weighted average)
        float totalReflectance = dot(diffuseAlbedo + specularAlbedo, float3(0.33333f, 0.33333f, 0.33333f));
      
        // Clamp to reasonable range
        totalReflectance = clamp(totalReflectance, 0.0f, 1.0f);
      
        if (totalReflectance > 0.0f)
        {
            path.updateCIRReflectance(totalReflectance);
        }
    }
}
```

ä½†æ˜¯æˆ‘å‘çŽ°è¿˜æœ‰ä¸€ä¸ªæ›´å…³é”®çš„é—®é¢˜ï¼š**è°ƒç”¨æ–¹å¼**ã€‚å½“å‰ä»£ç åœ¨ `handleHit`ä¸­è¿™æ ·è°ƒç”¨ï¼š

```hlsl
updateCIRDataDuringTracing(path, sd.faceN, bsdfProperties.diffuseReflectionAlbedo.r);
```

éœ€è¦ä¿®æ”¹è°ƒç”¨æ–¹å¼ï¼š

```hlsl:Source/RenderPasses/PathTracer/PathTracer.slang
// ... existing code at line 884 ...

        // === Update CIR data during path tracing ===
        updateCIRDataDuringTracing(path, sd.faceN, bsdfProperties);

// ... existing code ...
```

### å®Œæ•´ä¿®å¤ä»£ç 

è®©æˆ‘æä¾›å®Œæ•´çš„ä¿®å¤ï¼š

```hlsl:Source/RenderPasses/PathTracer/PathTracer.slang
/** Update CIR data during path tracing (corrected version).
    Fixed emission angle calculation timing and reflectance computation.
    \param[in,out] path Path state.
    \param[in] surfaceNormal Surface normal at hit point.
    \param[in] bsdfProperties BSDF properties for accurate reflectance calculation.
*/
void updateCIRDataDuringTracing(inout PathState path, float3 surfaceNormal, BSDFProperties bsdfProperties)
{
    const uint vertexIndex = path.getVertexIndex();
    const bool isPrimaryHit = (vertexIndex == 1);
  
    // ðŸ”§ Fix 1: Update emission angle when hitting an emissive surface (not based on vertex index)
    if (any(bsdfProperties.emission > 0.0f))
    {
        path.updateCIREmissionAngle(surfaceNormal);
    }
  
    // ðŸ”§ Fix 2: Accumulate reflectance using combined RGB reflectance (not single channel)
    // Only accumulate for actual surface interactions (not primary hit from camera)
    if (!isPrimaryHit)
    {
        // Calculate total reflectance as average of RGB channels
        float3 totalAlbedo = bsdfProperties.diffuseReflectionAlbedo + bsdfProperties.specularReflectionAlbedo;
        float avgReflectance = dot(totalAlbedo, float3(0.33333f, 0.33333f, 0.33333f));
      
        // Apply reflectance only if valid
        if (avgReflectance > 0.0f && avgReflectance <= 1.0f)
        {
            path.updateCIRReflectance(avgReflectance);
        }
    }
}
```

åŒæ—¶éœ€è¦ä¿®æ”¹ `handleHit`æ–¹æ³•ä¸­çš„è°ƒç”¨ï¼š

```hlsl:Source/RenderPasses/PathTracer/PathTracer.slang
// ... existing code at line 884 ...

        // === Update CIR data during path tracing ===
        updateCIRDataDuringTracing(path, sd.faceN, bsdfProperties);

// ... existing code ...
```

## ðŸ“‹ è¯Šæ–­æ€»ç»“

æ‚¨çš„CIRæ•°æ®é—®é¢˜**ä¸æ˜¯PathTraceré»˜è®¤è®¾ç½®å¼•èµ·çš„**ï¼Œè€Œæ˜¯**è®¡ç®—æ–¹æ³•çš„é€»è¾‘é”™è¯¯**ï¼š

### âŒ åŽŸæ¥çš„é—®é¢˜ï¼š

1. **EmissionAngle = 0**ï¼šåœ¨é”™è¯¯æ—¶æœºè®¡ç®—ï¼ˆç›¸æœºé¡¶ç‚¹è€Œéžå…‰æºè¡¨é¢ï¼‰
2. **ReflectanceProduct = 0**ï¼šä½¿ç”¨å•ä¸€é¢œè‰²é€šé“ï¼Œä¸”å¾ˆå¤šææ–™è¯¥é€šé“ç¡®å®žä¸º0

### âœ… ä¿®å¤åŽå°†å®žçŽ°ï¼š

1. **EmissionAngle**ï¼šåœ¨å‘å…‰è¡¨é¢æ­£ç¡®è®¡ç®—å‘å°„è§’
2. **ReflectanceProduct**ï¼šä½¿ç”¨RGBå¹³å‡å€¼è®¡ç®—æ­£ç¡®çš„è¡¨é¢åå°„çŽ‡
3. **å¯¹äºŽç›´æŽ¥è·¯å¾„**ï¼šReflectanceProductåº”è¯¥ä¿æŒåˆå§‹å€¼1.0ï¼ˆå› ä¸ºæ²¡æœ‰è¡¨é¢åå°„ï¼‰

è¿™äº›ä¿®å¤å°†è§£å†³æ‚¨çœ‹åˆ°çš„æ•°æ®å¼‚å¸¸é—®é¢˜ï¼Œä½¿CIRæ•°æ®æ›´å‡†ç¡®åœ°åæ˜ VLCä¼ æ’­è·¯å¾„çš„ç‰©ç†ç‰¹æ€§ã€‚
