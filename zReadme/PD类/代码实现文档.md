基于我们的分析，这里是整理后的实现方案：

## 实现方案概述

您需要实现三个主要部分：

1. 为PathTracer添加波长纹理输出通道
2. 扩展IncomingLightPowerPass实现高精度光功率分类统计
3. 添加UI控制和导出功能

## 1. PathTracer波长输出通道

首先需要修改PathTracer以输出波长信息。在现有的输出通道定义中 ，添加新的波长输出通道：

<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&_code]:block [&_code]:border-none [&_code]:bg-transparent [&_code]:p-0"><pre><code><span>// 在PathTracer.cpp中添加  </span><span>
</span><span></span><span>const</span><span> std::string kOutputWavelength = </span><span>"wavelength"</span><span>;
</span>
<span></span><span>// 在kOutputChannels中添加  </span><span>
</span><span>{ kOutputWavelength, </span><span>""</span><span>, </span><span>"Output wavelength per pixel"</span><span>, </span><span>true</span><span></span><span>/* optional */</span><span>, ResourceFormat::R32Float },</span></code></pre></pre>

PathTracer已经在PathState中跟踪波长信息 **PathState.slang:110** ，并有波长更新机制 **PathTracer.slang:1028-1029** 。

## 2. 扩展IncomingLightPowerPass

### 2.1 添加成员变量

在IncomingLightPowerPass.h的private部分 **IncomingLightPowerPass.h:142-171** 后添加：

<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&_code]:block [&_code]:border-none [&_code]:bg-transparent [&_code]:p-0"><pre><code><span>// Photodetector analysis parameters  </span><span>
</span><span></span><span>bool</span><span> mEnablePhotodetectorAnalysis = </span><span>false</span><span>;    </span><span>///< Enable photodetector power matrix analysis  </span><span>
</span><span></span><span>float</span><span> mDetectorArea = </span><span>1e-6</span><span>f;                  </span><span>///< PD effective area in m²  </span><span>
</span><span></span><span>float</span><span> mSourceSolidAngle = </span><span>1e-3</span><span>f;              </span><span>///< Source solid angle in sr  </span><span>
</span><span></span><span>uint32_t</span><span> mCurrentNumRays = </span><span>0</span><span>;                 </span><span>///< Current number of rays (dynamic)  </span><span>
</span>
<span></span><span>// High precision binning parameters (1nm and 1deg precision)  </span><span>
</span><span></span><span>float</span><span> mWavelengthMin = </span><span>380.0f</span><span>;                </span><span>///< Minimum wavelength for binning  </span><span>
</span><span></span><span>float</span><span> mWavelengthMax = </span><span>780.0f</span><span>;                </span><span>///< Maximum wavelength for binning  </span><span>
</span><span></span><span>float</span><span> mAngleMax = </span><span>90.0f</span><span>;                      </span><span>///< Maximum angle for binning  </span><span>
</span><span></span><span>uint32_t</span><span> mWavelengthBinCount = </span><span>400</span><span>;           </span><span>///< Number of wavelength bins (1nm precision)  </span><span>
</span><span></span><span>uint32_t</span><span> mAngleBinCount = </span><span>90</span><span>;                 </span><span>///< Number of angle bins (1deg precision)  </span><span>
</span>
<span></span><span>// Power matrix storage  </span><span>
</span><span>std::vector<std::vector<</span><span>float</span><span>>> mPowerMatrix; </span><span>///< Power matrix [wavelength][angle]  </span><span>
</span><span></span><span>float</span><span> mTotalPower = </span><span>0.0f</span><span>;                     </span><span>///< Total accumulated power  </span><span>
</span><span></span><span>uint32_t</span><span> mTotalRaysProcessed = </span><span>0</span><span>;             </span><span>///< Total rays processed</span></code></pre></pre>

### 2.2 修改Shader常量缓冲区

在现有的PerFrameCB **IncomingLightPowerPass.cs.slang:62-80** 中添加：

<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&_code]:block [&_code]:border-none [&_code]:bg-transparent [&_code]:p-0"><pre><code><span>//</span><span> Photodetector analysis parameters
</span><span>bool gEnablePhotodetectorAnalysis;    </span><span>//</span><span>/< Enable photodetector analysis
</span><span>float gDetectorArea;                  /</span><span>//</span><span>< Detector area </span><span>in</span><span> m²
</span><span>float gSourceSolidAngle;              </span><span>//</span><span>/< Source solid angle in sr
</span><span>uint gCurrentNumRays;                 /</span><span>//</span><span>< Current number of rays (dynamic)
</span>
<span></span><span>//</span><span> High precision binning parameters
</span><span>float gWavelengthMin;                 </span><span>//</span><span>/< Minimum wavelength (nm)
</span><span>float gWavelengthMax;                 /</span><span>//</span><span>< Maximum wavelength (nm)
</span><span>float gAngleMax;                      </span><span>//</span><span>/< Maximum angle (deg)
</span><span>uint gWavelengthBinCount;             /</span><span>//</span><span>< Number of wavelength bins
</span><span>uint gAngleBinCount;                  </span><span>//</span><span>/< Number of angle bins</span></code></pre></pre>

### 2.3 添加高精度分箱函数

<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&_code]:block [&_code]:border-none [&_code]:bg-transparent [&_code]:p-0"><pre><code><span>// 高精度分箱函数 (1nm和1度精度)  </span><span>
</span><span></span>uintfindWavelengthBin(float wavelength)<span>
</span>{
<span></span><span>if</span><span> (wavelength < gWavelengthMin || wavelength > gWavelengthMax)
</span><span></span><span>return</span><span></span><span>0xFFFFFFFF</span><span>; </span><span>// 无效bin标记  </span><span>
</span>
<span></span><span>// 1nm精度分箱  </span><span>
</span><span></span><span>uint</span><span> bin = </span><span>uint</span><span>((wavelength - gWavelengthMin));
</span><span></span><span>return</span><span> min(bin, gWavelengthBinCount - </span><span>1</span><span>);
</span>}

<span></span>uintfindAngleBin(float angleDeg)<span>
</span>{
<span></span><span>if</span><span> (angleDeg < </span><span>0.0f</span><span> || angleDeg > gAngleMax)
</span><span></span><span>return</span><span></span><span>0xFFFFFFFF</span><span>; </span><span>// 无效bin标记  </span><span>
</span>
<span></span><span>// 1度精度分箱  </span><span>
</span><span></span><span>uint</span><span> bin = </span><span>uint</span><span>(angleDeg);
</span><span></span><span>return</span><span> min(bin, gAngleBinCount - </span><span>1</span><span>);
</span>}</code></pre></pre>

### 2.4 修改主计算函数

在现有的main函数 **IncomingLightPowerPass.cs.slang:393-501** 中添加光功率分类计算：

<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&_code]:block [&_code]:border-none [&_code]:bg-transparent [&_code]:p-0"><pre><code><span>// 在computeLightPower后添加分类统计
</span>if (gEnablePhotodetectorAnalysis && power.w > 0)
{
    // 计算入射角
<span>    float3 </span><span>cameraNormal</span><span> = normalize(gCameraTarget - gCameraPosition)</span><span>;  </span><span>
</span><span>    float </span><span>cosTheta</span><span> = max(</span><span>0.0</span><span>f, dot(normalize(rayDir), cameraNormal))</span><span>;  </span><span>
</span><span>    float </span><span>incidentAngle</span><span> = acos(cosTheta) * </span><span>180.0</span><span>f / </span><span>3.14159</span><span>f</span><span>;  </span><span>
</span>
    // 计算每条光线的功率
<span>    float </span><span>deltaOmega</span><span> = gSourceSolidAngle / float(gCurrentNumRays)</span><span>;  </span><span>
</span><span>    float </span><span>totalPower</span><span> = (power.x + power.y + power.z) * deltaOmega</span><span>;  </span><span>
</span>
    // 分类到对应的bin
<span>    uint </span><span>wavelengthBin</span><span> = findWavelengthBin(wavelength)</span><span>;  </span><span>
</span><span>    uint </span><span>angleBin</span><span> = findAngleBin(incidentAngle)</span><span>;  </span><span>
</span>
    // 这里需要使用原子操作累加到功率矩阵
    // 由于shader限制，实际实现可能需要在CPU端处理
}</code></pre></pre>

## 3. 动态光线数量计算

在execute函数中动态计算光线数量：

<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&_code]:block [&_code]:border-none [&_code]:bg-transparent [&_code]:p-0"><pre><code>voidIncomingLightPowerPass::execute(RenderContext* pRenderContext, const RenderData& renderData)
<span>{
</span><span></span><span>// ... 现有代码 ...  </span><span>
</span>
<span></span><span>// 动态计算当前帧的光线数量  </span><span>
</span><span>    mCurrentNumRays = mFrameDim.x * mFrameDim.y; </span><span>// 每个像素一条光线  </span><span>
</span>
<span></span><span>// 如果有sample count输入，使用实际的采样数  </span><span>
</span><span></span><span>const</span><span></span><span>auto</span><span>& pSampleCount = renderData.</span><span>getTexture</span><span>(kInputSampleCount);
</span><span></span><span>if</span><span> (pSampleCount)
</span>    {
<span></span><span>// 读取实际的采样数并累加  </span><span>
</span><span></span><span>// 这里需要实现读取逻辑来获取真实的光线数量  </span><span>
</span>    }

<span></span><span>// 计算每条光线代表的立体角  </span><span>
</span><span></span><span>float</span><span> deltaOmega = mSourceSolidAngle / </span><span>float</span><span>(mCurrentNumRays);
</span>
<span></span><span>// 更新shader参数  </span><span>
</span><span>    var[</span><span>"gEnablePhotodetectorAnalysis"</span><span>] = mEnablePhotodetectorAnalysis;
</span><span>    var[</span><span>"gDetectorArea"</span><span>] = mDetectorArea;
</span><span>    var[</span><span>"gSourceSolidAngle"</span><span>] = mSourceSolidAngle;
</span><span>    var[</span><span>"gCurrentNumRays"</span><span>] = mCurrentNumRays;
</span><span>    var[</span><span>"gWavelengthMin"</span><span>] = mWavelengthMin;
</span><span>    var[</span><span>"gWavelengthMax"</span><span>] = mWavelengthMax;
</span><span>    var[</span><span>"gAngleMax"</span><span>] = mAngleMax;
</span><span>    var[</span><span>"gWavelengthBinCount"</span><span>] = mWavelengthBinCount;
</span><span>    var[</span><span>"gAngleBinCount"</span><span>] = mAngleBinCount;
</span>
<span></span><span>// ... 其余代码 ...  </span><span>
</span>}</code></pre></pre>

## 4. UI控制和导出功能

基于现有的UI实现 **IncomingLightPowerPass.cpp:1039-1143** ，添加光功率分析控制：

<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&_code]:block [&_code]:border-none [&_code]:bg-transparent [&_code]:p-0"><pre><code>voidIncomingLightPowerPass::renderUI(Gui::Widgets& widget)
<span>{
</span><span></span><span>// ... 现有UI代码 ...  </span><span>
</span>
<span></span><span>// 添加光功率分析UI  </span><span>
</span><span></span><span>auto</span><span> pdGroup = widget.</span><span>group</span><span>(</span><span>"Photodetector Analysis"</span><span>, </span><span>true</span><span>);
</span><span></span><span>if</span><span> (pdGroup)
</span>    {
<span></span><span>bool</span><span> pdChanged = widget.</span><span>checkbox</span><span>(</span><span>"Enable Analysis"</span><span>, mEnablePhotodetectorAnalysis);
</span>
<span></span><span>if</span><span> (mEnablePhotodetectorAnalysis)
</span>        {
<span>            pdChanged |= widget.</span><span>slider</span><span>(</span><span>"Detector Area (μm²)"</span><span>, mDetectorArea, </span><span>1e-8</span><span>f, </span><span>1e-3</span><span>f);
</span><span>            pdChanged |= widget.</span><span>slider</span><span>(</span><span>"Source Solid Angle (msr)"</span><span>, mSourceSolidAngle, </span><span>1e-6</span><span>f, </span><span>1e-1</span><span>f);
</span>
<span></span><span>// 显示当前光线数量（只读）  </span><span>
</span><span>            widget.</span><span>text</span><span>(</span><span>"Current Rays: "</span><span> + std::</span><span>to_string</span><span>(mCurrentNumRays));
</span>
<span></span><span>// 分箱参数配置  </span><span>
</span><span>            pdChanged |= widget.</span><span>slider</span><span>(</span><span>"Wavelength Min (nm)"</span><span>, mWavelengthMin, </span><span>300.0f</span><span>, </span><span>700.0f</span><span>);
</span><span>            pdChanged |= widget.</span><span>slider</span><span>(</span><span>"Wavelength Max (nm)"</span><span>, mWavelengthMax, </span><span>400.0f</span><span>, </span><span>800.0f</span><span>);
</span><span>            pdChanged |= widget.</span><span>slider</span><span>(</span><span>"Max Angle (deg)"</span><span>, mAngleMax, </span><span>30.0f</span><span>, </span><span>90.0f</span><span>);
</span>
<span></span><span>// 显示分箱信息  </span><span>
</span><span>            mWavelengthBinCount = </span><span>uint32_t</span><span>(mWavelengthMax - mWavelengthMin);
</span><span>            mAngleBinCount = </span><span>uint32_t</span><span>(mAngleMax);
</span><span>            widget.</span><span>text</span><span>(</span><span>"Wavelength Bins: "</span><span> + std::</span><span>to_string</span><span>(mWavelengthBinCount) + </span><span>" (1nm precision)"</span><span>);
</span><span>            widget.</span><span>text</span><span>(</span><span>"Angle Bins: "</span><span> + std::</span><span>to_string</span><span>(mAngleBinCount) + </span><span>" (1deg precision)"</span><span>);
</span>
<span></span><span>// 导出按钮  </span><span>
</span><span></span><span>if</span><span> (widget.</span><span>button</span><span>(</span><span>"Export Power Matrix"</span><span>))
</span>            {
<span></span><span>exportPowerMatrix</span><span>();
</span>            }

<span></span><span>if</span><span> (widget.</span><span>button</span><span>(</span><span>"Reset Statistics"</span><span>))
</span>            {
<span></span><span>resetPowerMatrix</span><span>();
</span>            }
        }

<span></span><span>if</span><span> (pdChanged)
</span>        {
<span>            mNeedRecompile = </span><span>true</span><span>;
</span><span></span><span>initializePowerMatrix</span><span>();
</span>        }
    }
}</code></pre></pre>

## 5. 功率矩阵导出实现

<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&_code]:block [&_code]:border-none [&_code]:bg-transparent [&_code]:p-0"><pre><code>boolIncomingLightPowerPass::exportPowerMatrix()
<span>{
</span><span>    std::string filename = mExportDirectory + </span><span>"/power_matrix_"</span><span> +
</span><span>                          std::</span><span>to_string</span><span>(std::</span><span>time</span><span>(</span><span>nullptr</span><span>)) + </span><span>".csv"</span><span>;
</span>
<span></span>std::ofstream file(filename)<span>;
</span><span></span><span>if</span><span> (!file.</span><span>is_open</span><span>()) </span><span>return</span><span></span><span>false</span><span>;
</span>
<span></span><span>// 写入表头  </span><span>
</span><span>    file << </span><span>"Wavelength(nm)\\Angle(deg)"</span><span>;
</span><span></span><span>for</span><span> (</span><span>uint32_t</span><span> j = </span><span>0</span><span>; j < mAngleBinCount; j++)
</span>    {
<span>        file << </span><span>","</span><span> << j;
</span>    }
<span>    file << </span><span>"\n"</span><span>;
</span>
<span></span><span>// 写入数据行  </span><span>
</span><span></span><span>for</span><span> (</span><span>uint32_t</span><span> i = </span><span>0</span><span>; i < mWavelengthBinCount; i++)
</span>    {
        file << (mWavelengthMin + i);
<span></span><span>for</span><span> (</span><span>uint32_t</span><span> j = </span><span>0</span><span>; j < mAngleBinCount; j++)
</span>        {
<span>            file << </span><span>","</span><span> << mPowerMatrix[i][j];
</span>        }
<span>        file << </span><span>"\n"</span><span>;
</span>    }

<span></span><span>// 写入汇总信息  </span><span>
</span><span>    file << </span><span>"\nTotal Power (W),"</span><span> << mTotalPower << </span><span>"\n"</span><span>;
</span><span>    file << </span><span>"Total Rays,"</span><span> << mTotalRaysProcessed << </span><span>"\n"</span><span>;
</span><span>    file << </span><span>"Delta Omega (sr),"</span><span> << (mSourceSolidAngle / </span><span>float</span><span>(mCurrentNumRays)) << </span><span>"\n"</span><span>;
</span>
<span>    file.</span><span>close</span><span>();
</span><span></span><span>logInfo</span><span>(</span><span>"Power matrix exported to "</span><span> + filename);
</span><span></span><span>return</span><span></span><span>true</span><span>;
</span>}

<span></span>voidIncomingLightPowerPass::initializePowerMatrix()
<span>{
</span><span></span><span>// 初始化功率矩阵  </span><span>
</span><span>    mPowerMatrix.</span><span>clear</span><span>();
</span><span>    mPowerMatrix.</span><span>resize</span><span>(mWavelengthBinCount, std::vector<</span><span>float</span><span>>(mAngleBinCount, </span><span>0.0f</span><span>));
</span><span>    mTotalPower = </span><span>0.0f</span><span>;
</span><span>    mTotalRaysProcessed = </span><span>0</span><span>;
</span>}</code></pre></pre>

## 更新渲染图连接

基于现有的连接示例 **IncomingLightPowerExample.py:28-30** ，需要添加波长连接：

<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&_code]:block [&_code]:border-none [&_code]:bg-transparent [&_code]:p-0"><pre><code><span># 在Python脚本中添加波长连接  </span><span>
</span><span>g.addEdge(</span><span>"PathTracer.wavelength"</span><span>, </span><span>"IncomingLightPower.wavelength"</span><span>)</span></code></pre></pre>


## 性能考虑

基于我们的分析，144KB的内存占用相对于Falcor系统的整体内存使用（如PathTracer的样本缓冲区 通常需要几十MB）来说微不足道，不会造成显著性能影响。

这个实现方案提供了：

* 1nm波长精度和1度角度精度的高精度分箱
* 动态光线数量计算
* 完整的UI控制界面
* CSV格式的功率矩阵导出
* 与现有Falcor架构的完全兼容性
