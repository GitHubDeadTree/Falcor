**调试和检查工具 Falcor还提供了像PixelInspector这样的工具来检查材质属性： PixelInspector.cs.slang:152-160 仔细讲讲这个工具如何使用，能够显示怎样的属性**

Fast

Searched across NVIDIAGameWorks/Falcor

你询问的是Falcor中的PixelInspector工具，这是一个用于调试和检查材质属性的强大工具。让我详细介绍它的使用方法和功能。

## PixelInspector工具概述

PixelInspector是Falcor提供的一个渲染通道(RenderPass)，用于检查特定像素的详细信息。它通过计算着色器实现，能够提取和显示像素的几何、材质和可见性数据。

## 工具的核心实现

PixelInspector的主要逻辑在计算着色器中实现 **PixelInspector.cs.slang:117-188** 。该着色器会：

1. 加载选定像素的G-buffer数据
2. 创建材质实例并获取BSDF属性
3. 将所有数据存储到PixelData结构中

## 如何使用PixelInspector

### 1. 像素选择

你可以通过两种方式选择要检查的像素：

* **连续检查模式** ：鼠标悬停时实时显示像素信息
* **点击选择模式** ：左键点击选择特定像素进行检查

这在UI界面中通过复选框控制 **PixelInspectorPass.cpp:178-184** 。

### 2. 输入数据要求

PixelInspector需要多种输入通道，包括：

* 世界空间位置 (`posW`)
* 法线信息 (`normW`, `tangentW`, `faceNormalW`)
* 纹理坐标 (`texC`)
* 材质数据 (`mtlData`)
* 颜色信息 (`linColor`, `outColor`)
* 可见性缓冲 (`vbuffer`)

这些输入通道的定义可以在 **PixelInspectorPass.cpp:41-54** 中看到。

## 能够显示的属性

### 1. 输出数据

* **线性颜色** ：色调映射前的颜色值
* **输出颜色** ：色调映射后的最终颜色
* **亮度** ：以cd/m²为单位的亮度值

这些在UI中的显示逻辑见 **PixelInspectorPass.cpp:220-241** 。

### 2. 几何数据

* **世界空间位置** ：像素在世界坐标系中的位置
* **着色法线** ：用于光照计算的法线
* **切线和副切线** ：用于法线贴图的切线空间
* **面法线** ：几何面的真实法线
* **视线向量** ：从像素到相机的方向
* **纹理坐标** ：UV坐标
* **正面朝向** ：是否为正面

几何数据的UI显示在 **PixelInspectorPass.cpp:243-311** 。

### 3. 材质属性

这是最重要的部分，包括完整的BSDF属性：

* **材质ID** ：材质的唯一标识符
* **双面材质** ：是否为双面材质
* **折射率(IoR)** ：材质的折射率
* **自发光** ：材质的发光属性
* **粗糙度** ：表面粗糙度
* **引导法线** ：用于降噪的代表性法线
* **漫反射反射率** (`diffuseReflectionAlbedo`)
* **漫反射透射率** (`diffuseTransmissionAlbedo`)
* **镜面反射率** (`specularReflectionAlbedo`)
* **镜面透射率** (`specularTransmissionAlbedo`)
* **镜面反射系数** (`specularReflectance`)
* **是否透射** ：材质是否具有透射属性

材质属性的UI实现在 **PixelInspectorPass.cpp:313-452** 。

### 4. 可见性数据

* **命中类型** ：三角形或曲线
* **实例ID** ：几何实例的标识符
* **图元索引** ：命中的图元索引
* **重心坐标** ：三角形内的重心坐标
* **变换矩阵** ：实例的变换信息
* **面朝向标志** ：各种面朝向相关的标志

可见性数据显示在 **PixelInspectorPass.cpp:454-504** 。

## 数据获取过程

工具通过以下步骤获取材质属性：

1. 从G-buffer加载几何数据 **PixelInspector.cs.slang:88-115**
2. 创建材质实例 **PixelInspector.cs.slang:132-134**
3. 获取BSDF属性并存储 **PixelInspector.cs.slang:152-160**

## Notes

PixelInspector是Falcor中非常实用的调试工具，它能够实时显示像素级别的详细信息，包括完整的材质BSDF属性。这对于材质调试、渲染问题诊断和理解渲染管线的工作原理都非常有帮助。工具支持多种输入格式，并能够处理不同分辨率的输入纹理。

你询问的是Falcor是否有现成的渲染图使用PixelInspector。让我搜索一下相关的渲染图配置和示例。

基于代码分析，我没有找到Falcor中包含PixelInspector的现成渲染图配置文件。不过，我可以看到PixelInspector是如何集成到渲染系统中的：

## PixelInspector的集成方式

PixelInspector被实现为一个标准的RenderPass **PixelInspectorPass.cpp:32-35** ，这意味着它可以像其他渲染通道一样添加到任何渲染图中。

## 如何在渲染图中使用PixelInspector

从RenderGraph的Python绑定可以看到，你可以通过以下方式创建和添加PixelInspector： **RenderGraph.cpp:738-745**

你需要：

1. **创建PixelInspector通道** ：

<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&_code]:block [&_code]:border-none [&_code]:bg-transparent [&_code]:p-0"><pre><code><span>graph.create_pass(</span><span>"PixelInspector"</span><span>, </span><span>"PixelInspectorPass"</span><span>)</span></code></pre></pre>

1. **连接必要的输入** ：PixelInspector需要多个输入通道 **PixelInspectorPass.cpp:41-54** ，包括：

* 世界空间位置 (`posW`)
* 材质数据 (`mtlData`)
* 可选的法线、纹理坐标等

1. **连接到其他渲染通道的输出** ：

<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&_code]:block [&_code]:border-none [&_code]:bg-transparent [&_code]:p-0"><pre><code><span>graph.add_edge(</span><span>"GBufferPass.posW"</span><span>, </span><span>"PixelInspector.posW"</span><span>)
   </span><span>graph.add_edge(</span><span>"GBufferPass.mtlData"</span><span>, </span><span>"PixelInspector.mtlData"</span><span>)</span></code></pre></pre>

## 实际使用示例

虽然没有现成的完整渲染图，但从代码中可以看到PixelInspector在实际项目中的使用模式。它通常作为调试工具添加到现有的渲染管线中，接收G-buffer通道的输出作为输入。

## Notes

Falcor采用了模块化的渲染图设计，PixelInspector作为一个独立的RenderPass可以灵活地集成到任何渲染管线中。你需要根据具体的渲染需求手动构建包含PixelInspector的渲染图，而不是使用预配置的模板。这种设计提供了更大的灵活性，但需要用户了解各个渲染通道之间的数据依赖关系。



你想要将PixelInspector集成到PathTracer渲染图中。基于代码分析，我可以为你提供具体的集成方法。

## PathTracer的输入输出接口

PathTracer渲染通道定义了多个输入和输出通道 **PathTracer.cpp:47-53** 。其中最重要的输入是visibility buffer (`vbuffer`)，输出包括颜色、反射率等多个通道。

## PixelInspector的输入需求

PixelInspector需要多个输入通道来获取完整的像素信息 **PixelInspectorPass.cpp:41-54** 。

## 集成方案

要将PixelInspector集成到PathTracer渲染图中，你需要一个G-buffer通道来提供几何和材质数据。参考现有的PathTracer渲染图示例 **PathTracerAdaptive.py:3-30** ，你可以按以下方式构建：

<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&_code]:block [&_code]:border-none [&_code]:bg-transparent [&_code]:p-0"><pre><code>defrender_graph_PathTracerWithPixelInspector():<span>
</span><span>    g = RenderGraph(</span><span>"PathTracerWithPixelInspector"</span><span>)
</span>
<span></span><span># 创建G-buffer通道  </span><span>
</span><span>    VBufferRT = createPass(</span><span>"VBufferRT"</span><span>, {</span><span>'samplePattern'</span><span>: </span><span>'Center'</span><span>, </span><span>'sampleCount'</span><span>: </span><span>16</span><span>, </span><span>'useAlphaTest'</span><span>: </span><span>True</span><span>})
</span><span>    g.addPass(VBufferRT, </span><span>"VBufferRT"</span><span>)
</span>
<span></span><span># 创建PathTracer通道  </span><span>
</span><span>    PathTracer = createPass(</span><span>"PathTracer"</span><span>, {</span><span>'useSER'</span><span>: </span><span>False</span><span>})
</span><span>    g.addPass(PathTracer, </span><span>"PathTracer"</span><span>)
</span>
<span></span><span># 创建PixelInspector通道  </span><span>
</span><span>    PixelInspector = createPass(</span><span>"PixelInspectorPass"</span><span>)
</span><span>    g.addPass(PixelInspector, </span><span>"PixelInspector"</span><span>)
</span>
<span></span><span># 连接G-buffer到PathTracer  </span><span>
</span><span>    g.addEdge(</span><span>"VBufferRT.vbuffer"</span><span>, </span><span>"PathTracer.vbuffer"</span><span>)
</span>
<span></span><span># 连接G-buffer数据到PixelInspector  </span><span>
</span><span>    g.addEdge(</span><span>"VBufferRT.posW"</span><span>, </span><span>"PixelInspector.posW"</span><span>)
</span><span>    g.addEdge(</span><span>"VBufferRT.normW"</span><span>, </span><span>"PixelInspector.normW"</span><span>)
</span><span>    g.addEdge(</span><span>"VBufferRT.tangentW"</span><span>, </span><span>"PixelInspector.tangentW"</span><span>)
</span><span>    g.addEdge(</span><span>"VBufferRT.faceNormalW"</span><span>, </span><span>"PixelInspector.faceNormalW"</span><span>)
</span><span>    g.addEdge(</span><span>"VBufferRT.texC"</span><span>, </span><span>"PixelInspector.texC"</span><span>)
</span><span>    g.addEdge(</span><span>"VBufferRT.mtlData"</span><span>, </span><span>"PixelInspector.mtlData"</span><span>)
</span><span>    g.addEdge(</span><span>"VBufferRT.vbuffer"</span><span>, </span><span>"PixelInspector.vbuffer"</span><span>)
</span>
<span></span><span># 连接PathTracer输出到PixelInspector  </span><span>
</span><span>    g.addEdge(</span><span>"PathTracer.color"</span><span>, </span><span>"PixelInspector.linColor"</span><span>)
</span>
<span></span><span># 标记最终输出  </span><span>
</span><span>    g.markOutput(</span><span>"PathTracer.color"</span><span>)
</span>
<span></span><span>return</span><span> g</span></code></pre></pre>

## 关键连接点

1. **G-buffer数据** ：PixelInspector需要从VBufferRT获取几何和材质信息
2. **颜色数据** ：PathTracer的输出颜色可以连接到PixelInspector的 `linColor`输入
3. **可见性缓冲** ：VBufferRT的vbuffer输出同时连接到PathTracer和PixelInspector

## 使用方式

集成后，PixelInspector会在UI中显示选定像素的详细信息，包括PathTracer计算出的颜色值以及完整的材质属性。你可以通过鼠标点击或悬停来选择要检查的像素。

## Notes

这种集成方式允许你在使用PathTracer进行路径追踪渲染的同时，实时检查任意像素的详细渲染信息，这对于调试材质和光照计算非常有用。PixelInspector会显示包括反射率、粗糙度、法线等在内的完整BSDF属性。
