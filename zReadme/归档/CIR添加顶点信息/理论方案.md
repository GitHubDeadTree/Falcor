根据您的需求，我将为您提供一个在 Falcor PathTracer 中存储每条光路顶点的完整实现方案。

## 实现方案概述

您需要让 PathTracer 存储每条光路的 5 个顶点坐标。基于前面的分析，我建议使用**独立缓冲区 + 压缩坐标**的方案，而不是扩展 PathPayload（因为 160 字节的限制）。

## 1. 扩展 CIRPathData 结构

首先，我们需要扩展现有的 CIRPathData 结构来包含顶点信息：

<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&_code]:block [&_code]:border-none [&_code]:bg-transparent [&_code]:p-0"><pre><code><span>// 在 CIRPathData.slang 中扩展结构  </span><span>
</span>struct CIRPathData
{
<span></span><span>// 现有字段保持不变  </span><span>
</span><span></span><span>float</span><span> pathLength;
</span><span></span><span>float</span><span> emissionAngle;
</span><span></span><span>float</span><span> receptionAngle;
</span><span></span><span>float</span><span></span><span>ref</span><span>lectanceProduct;
</span><span></span><span>uint</span><span></span><span>ref</span><span>lectionCount;
</span><span></span><span>float</span><span> emittedPower;
</span><span></span><span>uint</span><span> pixelX;
</span><span></span><span>uint</span><span> pixelY;
</span><span></span><span>uint</span><span> pathIndex;
</span>
<span></span><span>// 新增：压缩的顶点坐标（5个顶点，每个用2个uint存储）  </span><span>
</span><span></span><span>uint</span><span>2 compressedVertices[</span><span>5</span><span>];  </span><span>// 每个顶点 6 字节，总共 30 字节  </span><span>
</span><span></span><span>uint</span><span> vertexCount;             </span><span>// 实际顶点数量  </span><span>
</span><span></span><span>float</span><span>3 basePosition;          </span><span>// 基准位置（摄像机位置）  </span><span>
</span>};</code></pre></pre>

## 2. 在 PathState 中添加顶点收集功能

扩展 PathState 来收集顶点信息：

<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&_code]:block [&_code]:border-none [&_code]:bg-transparent [&_code]:p-0"><pre><code><span>// 在 PathState.slang 中添加顶点收集字段  </span><span>
</span>struct PathState
{
<span></span><span>// 现有字段保持不变...  </span><span>
</span>
<span></span><span>// 新增：顶点收集相关字段  </span><span>
</span><span></span><span>float</span><span>3 pathVertices[</span><span>5</span><span>];       </span><span>// 临时存储顶点坐标  </span><span>
</span><span></span><span>uint</span><span> pathVertexCount;         </span><span>// 当前顶点数量  </span><span>
</span><span></span><span>float</span><span>3 pathBasePosition;      </span><span>// 路径基准位置  </span><span>
</span>
<span></span><span>// 添加顶点收集方法  </span><span>
</span><span></span><span>    [mutating]</span><span></span><span>void</span><span> addPathVertex(</span><span>float</span><span>3 position)
</span>    {
<span></span><span>if</span><span> (pathVertexCount < </span><span>5</span><span>)
</span>        {
            pathVertices[pathVertexCount] = position;
            pathVertexCount++;
        }
    }
<span></span><span>
</span><span>    [mutating]</span><span></span><span>void</span><span> initPathVertexCollection(</span><span>float</span><span>3 cameraPos)
</span>    {
        pathBasePosition = cameraPos;
<span>        pathVertexCount = </span><span>0</span><span>;
</span><span></span><span>// 添加摄像机位置作为第一个顶点  </span><span>
</span>        addPathVertex(cameraPos);
    }
};</code></pre></pre>

## 3. 高效压缩和解压缩实现

基于 Falcor 现有的压缩技术，实现顶点坐标的压缩：

<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&_code]:block [&_code]:border-none [&_code]:bg-transparent [&_code]:p-0"><pre><code><span>// 顶点压缩工具函数
</span>uint2 compressVertex(float3 vertex, float3 basePosition)
{
    // 计算相对坐标
<span>    float3 </span><span>relative</span><span> = vertex - basePosition</span><span>;  </span><span>
</span>
    // 使用 16 位浮点数压缩
<span>    uint </span><span>x16</span><span> = f32tof16(relative.x)</span><span>;  </span><span>
</span><span>    uint </span><span>y16</span><span> = f32tof16(relative.y)</span><span>;  </span><span>
</span><span>    uint </span><span>z16</span><span> = f32tof16(relative.z)</span><span>;  </span><span>
</span>
<span>    uint2 compressed</span><span>;  </span><span>
</span><span></span><span>compressed.x</span><span> = (y16 << </span><span>16</span><span>) | x16</span><span>;  // 打包 x 和 y  </span><span>
</span><span></span><span>compressed.y</span><span> = z16</span><span>;                // z 单独存储  </span><span>
</span><span>    return compressed</span><span>;  </span><span>
</span>}

float3 decompressVertex(uint2 compressed, float3 basePosition)
{
    // 解压缩相对坐标
<span>    float </span><span>x</span><span> = f16tof32(compressed.x & </span><span>0</span><span>xFFFF)</span><span>;  </span><span>
</span><span>    float </span><span>y</span><span> = f16tof32(compressed.x >> </span><span>16</span><span>)</span><span>;  </span><span>
</span><span>    float </span><span>z</span><span> = f16tof32(compressed.y & </span><span>0</span><span>xFFFF)</span><span>;  </span><span>
</span>
<span>    float3 </span><span>relative</span><span> = float3(x, y, z)</span><span>;  </span><span>
</span><span>    return basePosition + relative</span><span>;  </span><span>
</span>}</code></pre></pre>

## 4. 修改 PathState 的 getCIRData 方法

<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&_code]:block [&_code]:border-none [&_code]:bg-transparent [&_code]:p-0"><pre><code><span>// 扩展 getCIRData 方法来包含顶点信息
</span>CIRPathData getCIRData()
{
<span>    CIRPathData cir</span><span>;  </span><span>
</span>
    // 现有字段赋值保持不变...
<span></span><span>cir.pathLength</span><span> = sceneLength</span><span>;  </span><span>
</span><span></span><span>cir.reflectionCount</span><span> = getBounces(BounceType::Diffuse) + getBounces(BounceType::Specular)</span><span>;  </span><span>
</span><span></span><span>cir.emittedPower</span><span> = getLightIntensity()</span><span>;  </span><span>
</span><span>    uint2 </span><span>pixel</span><span> = getPixel()</span><span>;  </span><span>
</span><span></span><span>cir.pixelX</span><span> = pixel.x</span><span>;  </span><span>
</span><span></span><span>cir.pixelY</span><span> = pixel.y</span><span>;  </span><span>
</span><span></span><span>cir.pathIndex</span><span> = id</span><span>;  </span><span>
</span><span></span><span>cir.reflectanceProduct</span><span> = cirReflectanceProduct</span><span>;  </span><span>
</span><span></span><span>cir.emissionAngle</span><span> = cirEmissionAngle</span><span>;  </span><span>
</span><span></span><span>cir.receptionAngle</span><span> = cirReceptionAngle</span><span>;  </span><span>
</span>
    // 新增：压缩顶点数据
<span></span><span>cir.basePosition</span><span> = pathBasePosition</span><span>;  </span><span>
</span><span></span><span>cir.vertexCount</span><span> = pathVertexCount</span><span>;  </span><span>
</span>
<span>    for (uint </span><span>i</span><span> = </span><span>0</span><span>; i < 5; i++)  </span><span>
</span>    {
        if (i < pathVertexCount)
        {
<span>            cir.compressedVertices</span><span>[i]</span><span> = compressVertex(pathVertices</span><span>[i]</span><span>, pathBasePosition)</span><span>;  </span><span>
</span>        }
        else
        {
<span>            cir.compressedVertices</span><span>[i]</span><span> = uint2(0, 0)</span><span>;  </span><span>
</span>        }
    }

<span>    return cir</span><span>;  </span><span>
</span>}</code></pre></pre>

## 5. 在光线追踪过程中收集顶点

修改 TracePass 中的光线追踪逻辑来收集顶点：

<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&_code]:block [&_code]:border-none [&_code]:bg-transparent [&_code]:p-0"><pre><code><span>// 在 tracePath 函数中添加顶点收集  </span><span>
</span><span>void trace</span>Path(uintpathID)<span>
</span>{
    PathState path = {};

<span>    gPathTracer.generate</span>Path(pathID, path)<span>;
</span><span>    gPathTracer.setup</span>PathLogging(path)<span>;
</span>
<span></span><span>// 初始化 CIR 数据和顶点收集  </span><span>
</span><span>    path.init</span>CIRData()<span>;
</span>
<span></span><span>// 获取摄像机位置并初始化顶点收集  </span><span>
</span>    float3 cameraPos = gScene.camera.data.posW;
<span>    path.init</span>PathVertexCollection(cameraPos)<span>;
</span>
<span></span><span>if</span><span> (path.is</span>Hit()<span>)
</span>    {
<span></span><span>// 添加第一个交点  </span><span>
</span><span>        float3 hitPos = path.origin + path.dir</span> * <span>path.sceneLength;
</span><span>        path.add</span>PathVertex(hitPos)<span>;
</span>
<span></span><span>// 处理主要命中...  </span><span>
</span><span></span><span>// 现有代码保持不变  </span><span>
</span>    }

<span></span><span>// 追踪路径  </span><span>
</span><span></span><span>while</span><span> (path.is</span>Active()<span>)
</span>    {
<span>        path.increment</span>VertexIndex()<span>;
</span>
<span></span><span>// 追踪光线  </span><span>
</span><span>        const Ray ray = path.get</span>ScatterRay()<span>;
</span><span></span><span>// ... 现有光线追踪代码 ...  </span><span>
</span>
<span></span><span>if</span><span> (hitObject.</span>IsHit()<span>)
</span>        {
<span>            path.set</span>Hit(makeHitInfo(hitObject)<span>);
</span><span>            path.sceneLength += hitObject.</span>GetRayDesc()<span>.TMax;
</span>
<span></span><span>// 添加新的交点顶点  </span><span>
</span><span>            float3 newHitPos = ray.origin + ray.dir</span> * <span>hitObject.</span>GetRayDesc()<span>.TMax;
</span><span>            path.add</span>PathVertex(newHitPos)<span>;
</span>        }

<span></span><span>// ... 其余处理逻辑保持不变 ...  </span><span>
</span>    }

<span></span><span>// 输出结果  </span><span>
</span><span>    gPathTracer.write</span>Output(path)<span>;
</span><span>    gPathTracer.output</span>CIRDataOnPathCompletion(path)<span>;
</span>}</code></pre></pre>

## 6. 更新 PixelStats 缓冲区

确保 CIR 数据缓冲区能够处理扩展后的数据结构。由于我们只是扩展了现有的 `CIRPathData` 结构，现有的缓冲区系统应该能够自动处理更大的数据结构。

## 7. 可视化顶点数据

在 CPU 端读取数据后，您可以使用解压缩函数来恢复顶点坐标：

<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&_code]:block [&_code]:border-none [&_code]:bg-transparent [&_code]:p-0"><pre><code><span>// 在 PixelStats.cpp 中添加顶点解压缩  </span><span>
</span><span></span>std::vector<float3> decompressPathVertices(const CIRPathData& cirData)
<span>{
</span>    std::vector<float3> vertices;
<span>    vertices.</span><span>reserve</span><span>(cirData.vertexCount);
</span>
<span></span><span>for</span><span> (</span><span>uint32_t</span><span> i = </span><span>0</span><span>; i < cirData.vertexCount && i < </span><span>5</span><span>; i++)
</span>    {
<span></span><span>// 使用 GPU 端相同的解压缩逻辑  </span><span>
</span>        uint2 compressed = cirData.compressedVertices[i];
<span></span><span>float</span><span> x = </span><span>f16tof32</span><span>(compressed.x & </span><span>0xFFFF</span><span>);
</span><span></span><span>float</span><span> y = </span><span>f16tof32</span><span>(compressed.x >> </span><span>16</span><span>);
</span><span></span><span>float</span><span> z = </span><span>f16tof32</span><span>(compressed.y & </span><span>0xFFFF</span><span>);
</span>
<span>        float3 relative = </span><span>float3</span><span>(x, y, z);
</span>        float3 worldPos = cirData.basePosition + relative;
<span>        vertices.</span><span>push_back</span><span>(worldPos);
</span>    }

<span></span><span>return</span><span> vertices;
</span>}</code></pre></pre>

## 总结

这个实现方案的优势：

1. **内存效率** ：每个顶点只需 6 字节（相比原始的 12 字节节省 50%）
2. **不影响 PathPayload** ：使用独立存储，避免了 160 字节限制
3. **基于现有架构** ：充分利用了 Falcor 现有的 CIR 数据收集系统
4. **高精度** ：16 位浮点数 + 相对坐标提供足够的精度用于可视化

通过这种方式，您可以有效地收集和存储每条光路的顶点信息，为后续的光路可视化提供数据基础。
