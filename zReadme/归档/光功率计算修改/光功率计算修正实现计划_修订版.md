# 光功率计算修正实现计划（修订版）

## 修改目标说明

### IncomingLightPowerPass中的两种功率计算方法：

1. **图像传感器功率计算**（Image Sensor Power Calculation）
   - 实现位置：`computeLightPower`函数
   - 用途：模拟相机图像传感器的功率接收
   - 计算方式：逐像素计算功率 `P_pixel = Radiance × PixelArea × cos(θ)`
   - CPU端处理：在`calculateStatistics`中累加所有像素功率

2. **光电探测器分析**（Photodetector Analysis）
   - 实现位置：main函数中的`gEnablePhotodetectorAnalysis`分支
   - 用途：模拟物理光电探测器(PD)的功率测量
   - 计算方式：`P_PD = Radiance × DetectorArea × cos(θ) × ΔΩ`
   - CPU端处理：收集角度-波长-功率数据点

### **本方案修改的是第1种：图像传感器功率计算**

## 新的物理公式方法

将图像传感器功率计算从逐像素累加改为基于物理公式的整体计算：

```
P_total = E_total × A_PD × cos(θ)
```

其中：
- **E_total**：从有效像素radiance值计算的平均辐照度（W/m²）
- **A_PD**：整个图像传感器的有效接收面积（m²）
- **cos(θ)**：光线与传感器法线的夹角修正因子

### 关键优势：
1. **物理正确性**：直接基于辐照度和面积的物理公式
2. **避免累加误差**：不需要逐像素累加功率
3. **计算简洁**：一次性计算整体功率
4. **距离衰减正确**：通过PathTracer的物理渲染自然体现

### 保持不变：
- **光电探测器分析功能**保持原有实现不变
- **Shader端的computeLightPower函数**仍需要为逐像素调试提供支持

## 任务概述

修正IncomingLightPowerPass的光功率计算，使其符合物理规律。**关键改进**：从原有的逐像素功率累加方法改为基于物理公式 `P_total = E_total × A_PD × cos(θ)` 的直接计算方法。

**核心发现**：`PathTracer`输出的`radiance`已经包含了基于物理的**1/r²距离衰减**，因此`IncomingLightPowerPass`中**无需**重复计算距离衰减。

### 方法论改进：
- **旧方法**：逐像素计算功率后累加 → 易产生累加误差，计算复杂
- **新方法**：直接使用整体物理公式 → 物理正确，计算简洁，误差更小

## 核心修改目标

### 针对图像传感器功率计算的修改：

1.  **像素面积修正**：在`computeLightPower`函数中，使用**单个像素**的物理面积进行计算，确保shader输出正确的像素功率。
2.  **CPU端总功率直接计算**：在`calculateStatistics`函数中，采用物理公式 `P_total = E_total × A_PD × cos(θ)` 直接计算整个图像传感器的总功率，替代现有的逐像素功率累加方法。
3.  **平均辐照度计算**：从有效像素的radiance值逆推计算平均辐照度E_total。
4.  **保持兼容性**：确保修改不影响光电探测器分析功能和调试功能。
5.  **验证与调试**：添加验证机制，确保修改后的计算结果正确并可追踪。

## 子任务分解

### 子任务1：修正像素面积计算 (Shader端)

#### 1. 任务目标
将shader中的`computePixelArea`函数修改为返回**单个像素的物理面积**。这是整个修正的基础。

#### 2. 实现方案

**修改文件**: `Source/RenderPasses/IncomingLightPowerPass/IncomingLightPowerPass.cs.slang`

**修改`computePixelArea`函数**:
```hlsl
// 原有错误实现
/*
float computePixelArea(uint2 dimensions)
{
    // ...
    float totalSensorArea = sensorWidth * sensorHeight;
    return totalSensorArea * gPixelAreaScale;  // 错误：返回总面积
}
*/

// 修正后的实现
float computePixelArea(uint2 dimensions)
{
    // 如果没有有效的维度信息，返回错误标识值
    if (dimensions.x == 0 || dimensions.y == 0) return 0.666e-8f;

    // 获取相机参数来计算传感器总面积
    // 这些参数（如fovY, aspectRatio）应从cbuffer传入
    float fovY = gCameraFovY; // 假设gCameraFovY已在cbuffer中定义
    float aspectRatio = float(dimensions.x) / float(dimensions.y);
    float distToImagePlane = 1.0f; // 标准化距离

    float sensorHeight = 2.0f * distToImagePlane * tan(fovY * 0.5f);
    float sensorWidth = sensorHeight * aspectRatio;
    float totalSensorArea = sensorWidth * sensorHeight;

    // 返回单个像素的面积
    float pixelArea = totalSensorArea / (float(dimensions.x) * float(dimensions.y));

    // 验证计算结果的有效性
    if (pixelArea <= 0.0f || !isfinite(pixelArea)) {
        return 0.666e-8f; // 0.666平方微米，明显的错误标识
    }

    return pixelArea * gPixelAreaScale; // gPixelAreaScale用于单位调整
}
```

**修改`computeLightPower`函数**:
```hlsl
float4 computeLightPower(uint2 pixel, uint2 dimensions, float3 rayDir, float4 radiance, float wavelength)
{
    // ... 现有的波长过滤逻辑保持不变 ...

    // 计算单个像素面积
    float pixelArea = computePixelArea(dimensions);

    // 计算cosTheta
    float cosTheta = computeCosTheta(rayDir);

    // 计算功率：P_pixel = Radiance * A_pixel * cos(θ)
    float3 power = radiance.rgb * pixelArea * cosTheta;

    // 验证功率计算结果
    if (any(!isfinite(power)) || any(power < 0.0f)) {
        return float4(0.666f, 0.666f, 0.666f, wavelength);
    }

    return float4(power, wavelength);
}
```

#### 3. 错误处理
-   检查`dimensions`参数，防止除以零。
-   检查计算出的`pixelArea`是否为正数且有限。
-   出错时返回一个极小的、可识别的错误值（`0.666e-8f`），以便于调试。

#### 4. 验证方法
-   在C++端，通过相机参数独立计算出的像素面积应与Shader计算结果近似相等。
-   调试输出中，单个像素功率值会非常小，并且随距离增加而减小（因为`radiance`本身就在减小）。

---

### 子任务2：基于物理公式的图像传感器总功率计算 (CPU端)

#### 1. 任务目标
在C++端，修改`calculateStatistics`函数，使用物理公式 `P_total = E_total × A_PD × cos(θ)` 直接计算整个图像传感器的总功率，替代现有的逐像素功率累加方法。

**重要说明**：此修改仅影响图像传感器功率计算路径，不影响光电探测器分析功能。

#### 2. 实现方案

**修改文件**: `Source/RenderPasses/IncomingLightPowerPass/IncomingLightPowerPass.cpp`

**修改`calculateStatistics`函数**:
```cpp
void IncomingLightPowerPass::calculateStatistics(RenderContext* pRenderContext, const RenderData& renderData)
{
    // ... readbackData逻辑保持不变 ...

    // 重置统计数据
    resetStatistics();

    // 第一步：从有效像素计算平均辐照度 E_total
    float3 totalRadiance = float3(0.0f);
    float totalCosTheta = 0.0f;
    uint32_t validPixelCount = 0;

    // 遍历图像传感器功率数据（注意：这里读取的是computeLightPower输出的像素功率）
    for (uint32_t i = 0; i < mPowerReadbackBuffer.size(); i++)
    {
        const float4& pixelPowerData = mPowerReadbackBuffer[i];

        // 检查像素功率是否有效
        if (pixelPowerData.x > 1e-12f || pixelPowerData.y > 1e-12f || pixelPowerData.z > 1e-12f)
        {
            // 检查是否有错误标识值
            if (abs(pixelPowerData.x - 0.666f) < 1e-6f) {
                logWarning("Shader reported a calculation error for a pixel.");
                continue;
            }

            // 从像素功率逆推原始radiance
            // P_pixel = Radiance × PixelArea × cos(θ)
            // 因此：Radiance = P_pixel / (PixelArea × cos(θ))
            float singlePixelArea = calculateSinglePixelArea();
            if (singlePixelArea > 0.0f)
            {
                // 简化假设：cos(θ) ≈ 1（对于接近垂直入射的光线）
                // 实际应用中可以从ray direction texture获取更精确的cos(θ)值
                float assumedCosTheta = 1.0f;
                float3 radiance = pixelPowerData.rgb / (singlePixelArea * assumedCosTheta);

                totalRadiance += radiance;
                totalCosTheta += assumedCosTheta;
                validPixelCount++;
            }
        }
    }

    if (validPixelCount == 0)
    {
        logWarning("No valid pixels found for power calculation");
        mPowerStats.totalPower[0] = mPowerStats.totalPower[1] = mPowerStats.totalPower[2] = 0.666f;
        return;
    }

    // 第二步：计算平均辐照度 E_total
    float3 averageRadiance = totalRadiance / float(validPixelCount);
    float averageCosTheta = totalCosTheta / float(validPixelCount);

    // 第三步：计算图像传感器总面积 A_sensor
    float totalSensorArea = calculateTotalDetectorArea();
    if (totalSensorArea <= 0.0f)
    {
        logError("Invalid total sensor area calculation");
        mPowerStats.totalPower[0] = mPowerStats.totalPower[1] = mPowerStats.totalPower[2] = 0.666f;
        return;
    }

    // 第四步：应用物理公式 P_total = E_total × A_sensor × cos(θ)
    float3 totalPower = averageRadiance * totalSensorArea * averageCosTheta;

    // 更新统计数据
    mPowerStats.totalPower[0] = totalPower.x;
    mPowerStats.totalPower[1] = totalPower.y;
    mPowerStats.totalPower[2] = totalPower.z;
    mPowerStats.pixelCount = validPixelCount;
    mPowerStats.totalPixels = mFrameDim.x * mFrameDim.y;

    // 计算平均功率（每个有效像素的等效功率）
    mPowerStats.averagePower[0] = totalPower.x / float(validPixelCount);
    mPowerStats.averagePower[1] = totalPower.y / float(validPixelCount);
    mPowerStats.averagePower[2] = totalPower.z / float(validPixelCount);

    // 验证最终结果
    if (totalPower.x < 0.0f || totalPower.y < 0.0f || totalPower.z < 0.0f)
    {
        logError("Calculated negative total power, using error marker");
        mPowerStats.totalPower[0] = mPowerStats.totalPower[1] = mPowerStats.totalPower[2] = 0.666f;
    }

    // 调试输出
    if (mDebugMode && (mFrameCount % 60 == 0))
    {
        logInfo(fmt::format("Image sensor physics-based power calculation:"));
        logInfo(fmt::format("  Average radiance: [{:.6e}, {:.6e}, {:.6e}] W/(m²·sr)",
                           averageRadiance.x, averageRadiance.y, averageRadiance.z));
        logInfo(fmt::format("  Total sensor area: {:.6e} m²", totalSensorArea));
        logInfo(fmt::format("  Average cos(θ): {:.4f}", averageCosTheta));
        logInfo(fmt::format("  Total power: [{:.6e}, {:.6e}, {:.6e}] W",
                           totalPower.x, totalPower.y, totalPower.z));
    }
}

// 新增辅助函数：计算图像传感器总面积
float IncomingLightPowerPass::calculateTotalDetectorArea() const
{
    return calculateSinglePixelArea() * float(mFrameDim.x * mFrameDim.y);
}
```

#### 3. 错误处理
-   验证逆推的radiance值是否合理
-   检查探测器总面积计算的正确性
-   验证最终总功率为非负数
-   出错时返回0.666标识值并记录详细错误信息

#### 4. 验证方法
-   图像传感器总功率应该使用公式 `P_total = E_total × A_sensor × cos(θ)` 计算
-   平均辐照度应该从有效像素功率逆推计算得出
-   总功率应该随光源距离变化（通过PathTracer的距离衰减体现）
-   调试输出显示计算公式的每个组成部分
-   验证修改不影响光电探测器分析功能的正常工作

---

### 子任务3：添加验证和调试功能

#### 1. 任务目标
添加完整的验证机制和调试UI/日志输出，确保修改后的计算结果正确并易于追踪。

#### 2. 实现方案

**在`IncomingLightPowerPass.cpp`中添加或修改**:
```cpp
// 在renderUI函数中添加调试信息显示
void IncomingLightPowerPass::renderUI(Gui::Widgets& widget)
{
    // ... 其他UI ...

    if (widget.collapsingHeader("Power Statistics"))
    {
        widget.text(fmt::format("Total Power (W): R={:.4e}, G={:.4e}, B={:.4e}",
            mPowerStats.totalPower[0], mPowerStats.totalPower[1], mPowerStats.totalPower[2]));
        widget.text(fmt::format("Average Power (W): R={:.4e}, G={:.4e}, B={:.4e}",
            mPowerStats.averagePower[0], mPowerStats.averagePower[1], mPowerStats.averagePower[2]));
        widget.text(fmt::format("Effective Pixels: {} / {}",
            mPowerStats.pixelCount, mPowerStats.totalPixels));

        // 添加一个按钮用于输出详细的相机和面积信息到日志
        if (widget.button("Log Debug Info")) {
            logCameraAndAreaInfo();
        }
    }
}

// 新增一个辅助函数用于记录详细日志
void IncomingLightPowerPass::logCameraAndAreaInfo()
{
    if (!mpScene || !mpScene->getCamera()) {
        logError("Cannot log debug info: No scene or camera available.");
        return;
    }
    auto camera = mpScene->getCamera();
    float fovY = camera->getFovY();
    float aspectRatio = float(mFrameDim.x) / float(mFrameDim.y);
    float totalArea = (2.f * tan(fovY * 0.5f) * aspectRatio) * (2.f * tan(fovY * 0.5f));
    float pixelArea = totalArea / (mFrameDim.x * mFrameDim.y);

    logInfo("====== Power Calculation Debug Info ======");
    logInfo(fmt::format("FoV Y: {:.2f} rad", fovY));
    logInfo(fmt::format("Aspect Ratio: {:.2f}", aspectRatio));
    logInfo(fmt::format("Dimensions: {}x{}", mFrameDim.x, mFrameDim.y));
    logInfo(fmt::format("Calculated Total Sensor Area: {:.6e} m^2", totalArea * mPixelAreaScale));
    logInfo(fmt::format("Calculated Single Pixel Area: {:.6e} m^2", pixelArea * mPixelAreaScale));
    logInfo("========================================");
}
```

#### 3. 错误处理
-   UI应能正确显示科学计数法，以应对非常小或非常大的功率值。
-   日志记录功能需要检查相机和场景是否存在，避免空指针。

#### 4. 验证方法
-   UI中显示的统计数据应与日志中记录的数据一致。
-   手动计算的像素面积应与日志中打印的值匹配。
-   `Total Power`应约等于`Average Power * Effective Pixels`。

## 实施顺序

1.  **子任务1** - 修正像素面积计算（Shader端）。这是最关键的第一步。
2.  **子任务2** - 修正统计计算（CPU端）。依赖于第一步的正确输出。
3.  **子任务3** - 添加验证和调试功能。用于验证前两步的成果。

## 总体验证标准

修改完成后，应该观察到：

### 物理公式验证：
-   总功率严格按照 `P_total = E_total × A_PD × cos(θ)` 计算
-   平均辐照度E_total从有效像素radiance值正确计算
-   探测器面积A_PD为所有像素面积之和
-   距离衰减通过PathTracer的radiance自然体现，无需重复计算

### 数值验证：
-   总功率随光源距离增加而按平方反比律减小
-   UI显示的数值符合物理直觉和量纲分析
-   调试输出显示公式各组成部分（E_total、A_PD、cos(θ)）数值合理
-   没有`0.666`错误标识值出现在正常计算结果中

### 一致性验证：
-   不同距离下的功率比值符合距离平方反比关系
-   计算结果与理论预期在数量级上一致
-   调试日志中的面积计算与独立验证结果匹配
