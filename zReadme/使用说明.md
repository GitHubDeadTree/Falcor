# Falcor 操作指南

本指南旨在为 Falcor 渲染框架的用户提供详尽的操作说明，涵盖基础环境配置、核心功能使用、参数调整及数据导出等。

---

## 0. 环境配置与构建

本章节介绍如何配置 Falcor 的开发环境并成功构建项目。正确的环境配置是顺利运行 Falcor 的第一步。

### 0.1. 系统与硬件要求

在开始之前，请确保您的系统满足以下最低要求 ([来源](https://github.com/NVIDIAGameWorks/Falcor)):

* **操作系统**: Windows 10 (版本 20H2 或更高版本)
* **开发环境**: Visual Studio 2022
* **Windows SDK**: 版本 10.0.19041.0 或更高
* **显卡 (GPU)**: 支持 DirectX Raytracing (DXR) 的 GPU，例如 NVIDIA Titan V 或 GeForce RTX 系列及更高型号。
* **显卡驱动**: NVIDIA 驱动程序版本 466.11 或更新。

### 0.2. 可选依赖项

为了启用 Falcor 的全部功能，您可能需要安装以下可选组件：

* **Windows 图形工具 (Graphics Tools)**: 对于运行 DirectX 12 调试层是必需的。可通过 Windows 的 "可选功能" -> "添加功能" -> "图形工具" 来安装。
* **NVAPI**: 启用 NVIDIA 特定的 API 功能。需从 NVIDIA 开发者网站下载并解压到 `external/packman/nvapi` 目录。
* **CUDA**: 启用 CUDA 加速计算。需从 NVIDIA 官网下载并安装 CUDA Toolkit (推荐 11.6.2 或更高版本)。
* **OptiX**: 用于 `OptixDenoiser` 降噪通道。需从 NVIDIA 开发者网站下载并将其 SDK 文件夹链接或复制到 `external/packman/optix`。

### 0.3. 项目构建

Falcor 使用 CMake 作为其构建系统。官方推荐使用以下两种方式进行构建：

#### 使用 Visual Studio 2022 【推荐】

1. 克隆 Falcor 仓库到本地。
2. 在仓库根目录运行 `setup_vs2022.bat` 批处理文件。
3. 该脚本会自动在 `build/windows-vs2022` 目录下生成 Visual Studio 的解决方案文件 (`.sln`)。
4. 使用 Visual Studio 2022 打开该解决方案文件，即可编译和运行项目。
5. 编译后的可执行文件位于 `build/windows-vs2022/bin` 目录下。

#### 使用 Visual Studio Code

1. 克隆 Falcor 仓库到本地。
2. 确保已安装 VS Code 和 **CMake Tools** 扩展。
3. 在仓库根目录运行 `setup.bat` 批处理文件，它会配置好 `.vscode` 工作区。
4. 在 VS Code 中打开 Falcor 根目录。
5. 使用快捷键 `Ctrl+Shift+P` 打开命令面板，执行 `CMake: Select Configure Preset`，然后选择 `windows-ninja-msvc` 预设。
6. 按下 `F7` 或点击状态栏中的 "Build" 按钮来编译项目。
7. 编译后的可执行文件位于 `build/windows-ninja-msvc/bin` 目录下。

---

## 1. 基础操作

本章节介绍启动和运行 Falcor 的基本步骤，包括如何加载渲染脚本和场景，以及如何配置相机、光源等核心渲染元素。

### 1.1. 加载资源

Falcor 的渲染过程由**渲染脚本 (Render Script)** 和**场景 (Scene)** 共同定义。

* **加载渲染脚本**:
  * **功能**: 渲染脚本是定义渲染流程的 Python 文件 (`.py`)。它决定了使用哪些渲染通道（Render Pass）以及它们如何连接，从而构建出最终的渲染效果（例如，路径追踪、光功率测量等）。
  * **操作**: 在主菜单栏选择 `File -> Load Script` 或使用快捷键 `Ctrl+O`，在弹出的文件浏览器中选择一个渲染脚本。Falcor 的 `scripts` 目录下提供了多种示例脚本。
* **加载场景**:
  * **功能**: 场景文件（如 `.pyscene`, `.gltf`）定义了渲染的静态环境，包含几何模型、材质、纹理、光源和相机等所有三维世界的元素。
  * **操作**: 在主菜单栏选择 `File -> Load Scene` 或使用快捷键 `Ctrl+Shift+O`，选择一个场景文件进行加载。

### 1.2. 相机配置 (Camera Configuration)

相机决定了我们观察场景的视角和方式，其参数模拟了真实世界中的物理摄像机，可在右侧的 "Scene" -> "Cameras" 窗口中进行配置。

* **核心参数**:
  * **Position / Target / Up**: 这三个向量共同定义了相机在三维空间中的位置和朝向。`Position` 是相机坐标，`Target` 是相机对准的目标点，`Up` 是相机的上方向向量。
  * **Focal Length (焦距)**: 单位为毫米(mm)。它决定了相机的视场角(Field of View, FOV)。焦距越短，视场越宽（广角镜头），透视效果越强；焦距越长，视场越窄（长焦镜头），画面更扁平。推荐值：`50mm` 适用于标准视角，`<35mm` 用于广角，`>70mm` 用于长焦。
* **景深 (Depth of Field) 与运动模糊 (Motion Blur) 参数**:
  * **Aperture Radius (光圈半径)**: 控制相机光圈的大小。光圈半径越大，景深效果越明显，即焦外区域的模糊程度越高。设置为 `0` 可禁用景深效果。
  * **Focal Distance (对焦距离)**: 设置焦平面到相机的距离。在该距离上的物体最为清晰，其他物体则根据与焦平面的距离产生模糊。
  * **Shutter Speed (快门速度)**: 单位为秒(s)。控制相机传感器曝光的时间。在渲染动态场景时，较慢的快门速度会产生更明显的运动模糊效果。
  * **ISO Speed (感光度)**: 模拟胶片或传感器的感光度。较高的ISO值会放大光线信号，使图像更亮，但这也会在物理上引入更多噪声。
* **其他参数**:
  * **Depth Range (Near/Far)**: 定义相机的近、远裁切平面。只有在这两个平面之间的物体才会被渲染，用于控制渲染范围，避免渲染过近或过远的物体。
  * **Aspect Ratio (宽高比)**: 决定最终输出图像的宽度与高度之比。通常根据输出窗口大小自动设定。

### 1.3. 光源配置 (Light Configuration)

光源是场景照明的来源，可在 "Scene" -> "Lights" 窗口中配置。Falcor支持多种光源类型。

* **通用属性**:
  * **Active**: 勾选此项可激活或禁用光源。
  * **Color**: 设置光源发出的光的颜色。
  * **Intensity**: 控制光源的亮度（辐射强度，单位为 W/sr）。
* **点光源 (Point Light) / 聚光灯 (Spotlight)**:
  * **概述**: 点光源从单点向所有方向均匀发光。通过限制其发光角度，可以变为聚光灯。
  * **World Position**: 设置光源在世界坐标系中的位置。
  * **Direction**: 设置聚光灯的照射方向。
  * **Opening Angle**: 聚光灯的锥形张角（单位：度）。决定了光照范围。当设置为180度时，效果等同于向半球发光的点光源。
  * **Penumbra Width**: 聚光灯光斑边缘的柔和度。角度越大，边缘过渡越平滑。
  * **功率与强度双模式**: 点光源提供两种控制模式，方便用户在物理精度和艺术创作之间切换。
    * **强度驱动 (Intensity-driven)**: 默认模式。直接控制光源的辐射强度。改变开口角度时，总功率会随之变化。
    * **功率驱动 (Power-driven)**: 通过 `Power (Watts)` 输入框设置光源的总辐射功率（单位：瓦特）。此模式下，当改变开口角度时，系统会自动调整强度以保持总功率不变，这对于进行物理精确的光学仿真至关重要。
* **方向光 (Directional Light)**:
  * **概述**: 模拟来自无限远处的光源（如太阳），其光线相互平行。此光源的位置无效，仅方向有效。
  * **Direction**: 设置光线的照射方向。
* **远光源 (Distant Light)**:
  * **概述**: 方向光的变种，额外考虑了光源的角直径，用于模拟太阳等有一定面积的远方光源，可以产生软阴影。
  * **Angle**: 控制光源的角大小（单位：度）。值越大，产生的阴影边缘越柔和。
* **LED 光源 (LEDLight)**:
  * **概述**: `LEDLight` 是一个为精确模拟真实世界LED特性而设计的专用光源。它支持复杂的几何形状、功率驱动的强度计算、角度衰减控制，并能从外部文件加载实测的光谱和光场分布数据，是进行专业光学和照明仿真的工具。
  * **几何参数**:
    * `Shape Type`: 下拉菜单，可选择 `Sphere` (球形), `Ellipsoid` (椭球), 或 `Rectangle` (矩形) 来定义LED的基本形状。
    * `Scale`: 一个三维向量，用于独立缩放X, Y, Z轴，可以创建任意尺寸和比例的LED。
  * **光学参数**:
    * `Opening Angle`: 定义光源发光的有效锥形张角（单位：弧度），超出此角度的光将被裁剪。
    * `Power (Watts)`: 以瓦特为单位设置LED的总辐射功率。`LEDLight` 会基于此功率、几何形状的表面积以及光场分布自动计算出物理准确的辐射亮度（Intensity）。这是该光源的核心特性之一。
    * `Lambert Exponent`: 朗伯指数。控制光强如何随偏离主方向的角度而衰减。指数越高，光线越集中于中心方向。**注意**: 当加载了自定义光场数据后，此参数将自动禁用，因为光场数据提供了更精确的分布模式。
  * **数据驱动模式**:
    * `LEDLight` 最强大的功能是其数据驱动特性。在UI中，你可以看到当前的光分布模式（Spectrum 和 Light Field）。
    * **默认模式**: 在未加载任何外部数据时，光源使用均匀的白光光谱和朗伯分布模型。
    * **加载自定义数据**: 通过在Python脚本中调用 `ledLight.loadSpectrumFromFile(...)` 和 `ledLight.loadLightFieldFromFile(...)`，可以分别加载 `.txt` 或 `.csv` 格式的光谱和光场数据。
    * **UI状态**: 加载成功后，UI会显示"Spectrum: X data points loaded"和"Light Field: Y data points loaded"，并且朗伯指数控件会被禁用。
    * `Clear Custom Data`: 此按钮可以清除所有已加载的光谱和光场数据，恢复到默认的朗伯模型。

### 1.4. 发光材质配置 (Emissive Materials)

除了使用光源对象，还可以将场景中的任何物体变为发光源。

* **操作**: 在 "Scene" -> "Materials" 窗口中选中目标物体的材质，在材质属性中找到 `Emissive`（自发光）选项。将其颜色设置为非黑色（如白色），该物体就会开始发光。发光的亮度和颜色由该颜色值的强度和色调决定。

### 1.5. 色调映射器 (Tone Mapper)

渲染引擎内部计算的是高动态范围（HDR）的颜色值，其亮度范围远超普通显示器所能展示的范围。色调映射器（Tone Mapper）的作用就是将HDR图像转换为显示器可以正常显示的低动态范围（LDR）图像。

* **核心参数**:
  * **Auto Exposure (自动曝光)**: 勾选后，系统会分析画面的平均亮度，并自动调整曝光，以达到视觉上舒适的亮度。
  * **Exposure Compensation (曝光补偿)**: 在自动曝光开启时，提供一个额外的亮度修正值，可用于微调整体画面的明暗。
  * **Operator**: 选择不同的色调映射算法，例如 `Reinhard`、`ACES`, `HableUc2` 等。不同的算子会产生不同的色彩和对比度风格，可根据艺术需求选择。
  * **White Balance (白平衡)**: 勾选后，可调整 `White Point (K)`（白点色温，单位：开尔文），用于校正画面中的色偏，使白色物体在不同色温的光照下看起来仍然是白色。

### 1.6. 视角管理 (Viewpoint Management)

Falcor 提供了强大的视角管理功能，允许用户保存多个摄像机位置并在它们之间快速切换。这对于批量测量、场景预览和自动化分析非常有用。

#### 1.6.1. 视角基本操作

视角管理功能位于右侧的 "Scene" -> "Settings" 面板中：

* **Add Viewpoint (添加视角)**:
  * **功能**: 将当前摄像机的位置、目标点和朝向保存为一个新的视角。
  * **操作**: 调整摄像机到理想位置后，点击 `Add Viewpoint` 按钮。系统会自动保存当前的摄像机参数。
  * **命名**: 新添加的视角会自动编号（如 "Viewpoint 1", "Viewpoint 2" 等），并出现在视角下拉列表中。

* **Remove Viewpoint (移除视角)**:
  * **功能**: 删除选中的视角。
  * **操作**: 在视角下拉列表中选择要删除的视角，然后点击 `Remove Viewpoint` 按钮。
  * **限制**: 无法删除默认视角（"Default"）。

* **视角选择与切换**:
  * **功能**: 在已保存的视角之间快速切换。
  * **操作**: 使用视角下拉列表选择目标视角，摄像机会立即移动到该位置。
  * **应用**: 对比不同角度的渲染效果，或用于批量分析工作流程。

#### 1.6.2. 视角数据导入导出

* **Save Viewpoints (导出视角)**:
  * **功能**: 将所有已保存的视角信息导出到文本文件。
  * **操作**: 点击 `Save Viewpoints` 按钮，选择保存路径和文件名。
  * **用途**: 备份视角信息、团队协作共享、批量处理任务准备。

* **Load Viewpoints (导入视角)**:
  * **功能**: 从之前导出的文件中恢复视角信息。
  * **操作**: 点击 `Load Viewpoints` 按钮，选择视角文件进行导入。
  * **注意**: 导入操作会清除当前的视角列表（除默认视角外），并用文件中的视角替换。

#### 1.6.3. 视角文件格式

导出的视角文件采用特定的文本格式，每行代表一个视角：

```
timePoint, Transform(position = float3(x, y, z), target = float3(x, y, z), up = float3(x, y, z))
```

**参数详解**:
* `timePoint`: 时间点（浮点数，用于动画路径）
* `position`: 摄像机位置坐标 (x, y, z)
* `target`: 摄像机对准的目标点坐标 (x, y, z)
* `up`: 摄像机的上方向向量 (x, y, z)

**示例**:
```
0.000000, Transform(position = float3(5.2, 3.1, -2.8), target = float3(0.0, 1.0, 0.0), up = float3(0.0, 1.0, 0.0))
1.000000, Transform(position = float3(-3.5, 2.8, 4.1), target = float3(0.0, 0.5, 0.0), up = float3(0.0, 1.0, 0.0))
```

#### 1.6.4. 批量测量准备

视角管理是进行批量光功率测量的前提：

1. **规划测量点**: 在场景中手动调整摄像机到各个需要测量的位置。
2. **保存视角**: 在每个位置使用 `Add Viewpoint` 保存视角。
3. **导出数据**: 使用 `Save Viewpoints` 将视角信息导出为文件。
4. **批量处理**: 在光功率测量脚本中使用导出的视角文件进行自动化批量测量。

---

## 2. 光功率测量 (Light Power Measurement)

此功能用于测量场景中特定区域接收到的光功率，常用于光学分析和照明工程。支持单点测量和批量自动化测量两种模式。

* **渲染脚本**: `IncomingLightPowerExample.py`
* **核心渲染通道**: `IncomingLightPowerPass`

### 2.1. 使用方法

#### 单点测量

1. 加载 `IncomingLightPowerExample.py` 渲染脚本。
2. 加载需要分析的场景。
3. 在渲染图编辑器中，选中 `IncomingLightPowerPass` 节点以在右侧UI面板显示其参数。
4. 勾选 **"Enable Statistics"**，这是获取测量结果的前提。
5. 在 **"Power Statistics"** 组中即可看到实时的光功率测量结果，如总功率（Total Power）、平均功率（Average Power）等。

#### 批量自动化测量

**前提条件**: 必须先准备视角文件。

1. **准备视角数据**:
   * 使用视角管理功能（见 1.6 节）在场景中添加需要测量的各个位置的视角。
   * 通过 `Save Viewpoints` 导出视角文件，用于自动化批量测量。

2. **启用批量模式**:
   * 在 `IncomingLightPowerPass` 参数面板中找到批量处理相关选项。
   * 加载之前保存的视角文件作为测量点列表。

3. **执行批量测量**:
   * 系统会自动遍历视角文件中的每个位置。
   * 在每个视角位置等待指定帧数（`Frames to wait` 参数）以确保渲染稳定。
   * 自动记录该位置的光功率数据。

4. **数据收集**:
   * 所有测量位置的数据会被自动收集和整理。
   * 可通过导出功能将完整的批量测量结果保存为 CSV 或 JSON 格式。

### 2.2. 参数详解

* **Enable Statistics**: 必须勾选，否则无法计算和显示统计数据。
* **Statistics Frequency**: 设置统计数据的更新频率（单位：帧）。值越高，UI更新越不频繁，但性能开销越小。
* **Frames to wait**: 在使用"自动视点处理"功能时，此参数定义了每次切换视点后，需要等待多少帧才进行数据采集。目的是等待渲染稳定，确保数据准确性。
* **Wavelength Filter (波长过滤器)**:
  * 一个强大的工具，允许你只测量特定波长范围内的光功率。
  * **Filter Mode**:
    * `Range`: 测量一个最小和最大波长之间的光。
    * `Specific Bands`: 测量特定波长及其附近（可设置容差），并提供了例如汞灯等光源的预设。
* **导出数据 (Export)**:
  * UI界面提供了导出按钮，可以将采集到的详细数据或统计数据保存为 `CSV` 或 `JSON` 格式，以便在其他软件中进行后续分析。可以设置导出目录和文件名。

---

## 3. CIR 响应测量 (Channel Impulse Response)

CIR（信道脉冲响应）测量用于分析光信号在空间中从发射端到接收端所经历的全部路径信息，是进行无线光通信（VLC）信道建模和仿真的关键。Falcor通过对核心的 `PathTracer` 进行扩展，实现了强大的CIR数据收集与分析功能。

**核心原理**: 该功能通过修改 `PathTracer` 的底层着色器代码，在每条光线完成其弹射路径后，并不像常规渲染那样简单地累加颜色值，而是将该路径的详细物理信息（如总长度、反射次数、出射/入射角度、功率衰减等）作为一个结构体 `CIRPathData` 保存到一个专用的GPU缓冲区中。在帧结束时，可以将这些海量的原始路径数据从GPU回读到CPU，以供后续的科学计算和信道分析。

### 3.1. 使用方法：启用与数据收集

CIR功能的控制和数据导出界面，并非直接位于 `PathTracer`的UI面板中，而是巧妙地集成在了 `Statistics` (统计) -> `Ray stats` (即 `PixelStats` 模块) 面板下。

1. **加载渲染图**: 加载使用 `PathTracer` 的渲染脚本，例如 `PathTracer.py`。
2. **打开统计面板**: 在主UI的 `Statistics` 菜单组中，找到并展开 **`Ray stats`** 面板。
3. **启用CIR数据收集**: 在 `Ray stats` 面板中，找到并勾选 **`Enable CIR Debug Mode`** 复选框。
   * **重要提示**: 如UI中的工具提示所示，启用此模式会收集海量的底层调试与路径数据，将对渲染性能产生**显著影响**。仅在需要进行CIR数据分析时开启。
4. **设置数据容量**: 通过调整 **`Max debug entries per frame`** 参数，可以限制单帧内允许记录的最大光路条目数，以防止内存溢出。
5. **运行渲染**: 启用后，`PathTracer` 会在后台持续不断地收集光路数据并累积在缓冲区中。

### 3.2. 参数配置与数据导出

在 `Ray stats` 面板中，除了启用开关，还提供了数据导出功能：

* **UI控件**:
  * `Print CIR Debug Info`: 点击此按钮，会将当前收集到的调试信息和分类统计打印到Falcor的控制台窗口中。
  * `Export CIR Debug Info`: 点击此按钮，会将所有收集到的原始路径数据和调试信息导出到一个CSV或其他格式的文本文件中，以便在外部工具（如MATLAB, Python）中进行专业的信道脉冲响应分析。
* **过滤参数**:
  * `PathTracer` 的CIR功能本身提供了底层的过滤机制，允许开发者通过修改着色器代码 (`.slang` 文件) 来实现更复杂的实时数据筛选。例如，可以添加逻辑以仅记录满足特定条件（如路径长度、反射次数）的光路。
  * UI中可能不直接暴露所有过滤参数，高级过滤通常需要在代码层面或通过后处理脚本实现。

### 3.3. 注意事项与最佳实践

* **发光体选择**: 为了精确测量包含直射路径（Line-of-Sight, LoS）在内的完整信道响应，强烈建议**不要**使用Falcor中的抽象光源对象（如 `PointLight`），因为光线追踪器可能不会将从相机直接"看"到光源的过程记录为一条有效的物理路径。
  * **正确做法**: 应在场景中创建一个实际的几何体（例如一个小的平面或球体），并为其赋予**自发光材质 (Emissive Material)**。这样，从该发光面发出的光线所形成的路径才会被CIR收集器完整地捕获。
* **性能考量**: CIR数据收集是一个极其消耗资源的过程。在进行大规模场景分析时，建议：
  * 在 `PathTracer`中适当降低"每像素采样数"(Samples/pixel)，因为我们关心的是大量路径的统计分布，而非单张图像的视觉质量。
  * 逐步增加 `Max debug entries per frame` 的值，避免一次性分配过大的GPU缓冲区。
* **后处理分析**: `PathTracer` 负责"收集"和"导出"原始数据。所有复杂的物理量计算，如**RMS时延扩展、相干带宽、信噪比（SNR）估算**等，都需要在外部的后处理脚本（如 `cir_calculator.py`）中完成。导出的CSV文件就是这两个阶段之间的桥梁。

---

## 4. Python 场景脚本配置

Falcor 提供了强大的 Python 接口（通过 `pyscene` 文件），允许通过脚本来动态地创建、加载和修改场景。这为自动化测试、批量渲染和程序化场景生成提供了极大的灵活性。

`sceneBuilder` 对象是构建场景的核心，它提供了添加网格、光源、相机和环境贴图等一系列方法。

### 4.1. 导入外部场景与网格

对于已经制作好的复杂模型，最常用的方法是直接导入。

* **方法**: `sceneBuilder.importScene("path/to/your/scene.gltf")`
* **说明**: 此函数可以加载多种标准格式的场景文件（如 `.gltf`, `.gltb`, `.obj`, `.fbx` 等），它会自动导入文件中包含的所有网格、材质和层级结构。

**代码示例**:

```python
# 从文件加载一个复杂的教室模型
sceneBuilder.importScene('classroom_cir/Classroom_cir.gltf')
```

### 4.2. 创建程序化几何体

除了导入外部模型，也可以在脚本中直接创建简单的几何体。

* **方法**:
  * `TriangleMesh.createCube()`: 创建一个单位立方体。
  * `TriangleMesh.createSphere()`: 创建一个单位球体。
  * `TriangleMesh.createQuad()`: 创建一个单位四边形（平面）。
* **说明**: 这些函数创建的是基础网格对象。要将它们放入场景，需要创建网格实例。
* **实例化网格**: `sceneBuilder.addMeshInstance(node, mesh)`
  * `node`: 定义了物体的位置、旋转和缩放。通过 `sceneBuilder.addNode('NodeName', Transform(...))` 创建。
  * `mesh`: 定义了物体的几何形状和材质。通过 `sceneBuilder.addTriangleMesh(meshObject, materialObject)` 创建。

**代码示例**:

```python
# 1. 创建一个标准材质
boxMaterial = StandardMaterial('MyBoxMaterial')
boxMaterial.baseColor = float4(0.8, 0.2, 0.2, 1.0) # 红色

# 2. 创建一个立方体网格
cubeMesh = TriangleMesh.createCube()

# 3. 创建一个变换节点，将立方体放大并向上移动
boxNode = sceneBuilder.addNode('MyBoxNode', Transform(scaling=float3(2.0, 2.0, 2.0), translation=float3(0, 1, 0)))

# 4. 创建带材质的网格对象
boxMeshId = sceneBuilder.addTriangleMesh(cubeMesh, boxMaterial)

# 5. 将节点和网格组合成实例，添加到场景中
sceneBuilder.addMeshInstance(boxNode, boxMeshId)
```

### 4.3. 配置光源

一个场景可以没有几何体，但不能没有光。

* **创建光源**:
  * `PointLight.create('name')`: 创建点光源。
  * `DirectionalLight.create('name')`: 创建方向光。
  * `EnvMap('path/to/hdr')`: 创建环境光。
  * `LEDLight.create('name')`: 创建具有特殊属性的LED光源。
* **添加光源**: `sceneBuilder.addLight(myLight)`

**代码示例**:

```python
# 创建一个点光源
pointLight = PointLight.create('MyPointLight')
pointLight.position = float3(0, 5, 0)
pointLight.intensity = float3(100, 100, 100) # 设置一个较强的白色光源
pointLight.openingAngle = 3.14159 # 设置为Π，使其成为一个全向点光源
sceneBuilder.addLight(pointLight)

# 创建一个环境光
envMap = EnvMap('envmaps/my_sky.hdr')
envMap.intensity = 1.5
sceneBuilder.envMap = envMap
```

### 4.4. 设置与修改材质

材质决定了物体表面的外观。你可以创建新材质，也可以获取并修改已加载场景中的材质。

* **创建标准材质**: `myMaterial = StandardMaterial('MyMaterialName')`
* **获取现有材质**:
  * `myMaterial = sceneBuilder.getMaterial('MaterialNameInScene')`
* **修改材质属性**: 获取材质对象后，直接修改其属性即可。

#### 4.4.1. 常用材质属性

* `baseColor`: 基础颜色（对于非金属是漫反射颜色，对于金属是反射颜色）。
* `metallic`: 金属度。`0` 代表电介质（如塑料、木材），`1` 代表金属。
* `roughness`: 粗糙度。`0` 代表完全光滑的镜面，`1` 代表完全粗糙的漫反射表面。
* `specularTransmission`: 镜面透射度，用于创建透明物体（如玻璃）。值为 `1` 时完全透明。
* `indexOfRefraction`: 折射率，与 `specularTransmission` 配合使用。
* `doubleSided`: `True` 或 `False`，设置材质是否双面渲染。

**代码示例**:

```python
# 1. 创建一个光滑的蓝色金属球材质
metalMaterial = StandardMaterial('BlueMetal')
metalMaterial.baseColor = float4(0.2, 0.3, 0.9, 1.0)
metalMaterial.metallic = 1.0
metalMaterial.roughness = 0.1

# 2. 获取场景中一个名为 "Wall" 的现有材质，并将其改为绿色
wallMaterial = sceneBuilder.getMaterial('Wall')
if wallMaterial:
    wallMaterial.baseColor = float4(0.1, 0.8, 0.1, 1.0)
```

#### 4.4.2. 设置发光平面

任何物体都可以通过设置其材质的自发光属性来变成光源。

* `emissiveColor`: 发光的颜色。
* `emissiveFactor`: 发光强度/亮度因子。

**代码示例**:

```python
# 创建一个自发光材质
lightMaterial = StandardMaterial('LightMaterial')
lightMaterial.emissiveColor = float3(17, 12, 4) # 温暖的橙色光
lightMaterial.emissiveFactor = 5.0 # 设置发光强度

# 将该材质应用到一个平面上，使其成为一个面光源
quadMesh = TriangleMesh.createQuad()
lightNode = sceneBuilder.addNode('LightPlane', Transform(translation=float3(0, 5, 0), scaling=float3(2, 1, 2)))
lightMeshId = sceneBuilder.addTriangleMesh(quadMesh, lightMaterial)
sceneBuilder.addMeshInstance(lightNode, lightMeshId)
```

### 4.5. 示例场景解析 (Example Scenes)

`media/test_scenes` 目录中包含了大量功能各异的示例场景脚本（`.pyscene` 文件），它们是学习和掌握 Falcor 脚本编写的最佳参考。下面对几个有代表性的场景进行解析：

#### 1. `cornell_box.pyscene` - 基础构建

* **用途**: 这是计算机图形学中最经典的测试场景之一，非常适合用于理解和测试全局光照（Global Illumination）算法。
* **功能演示**:

  * **程序化几何体**: 完全由脚本创建，使用 `TriangleMesh.createQuad()` 和 `TriangleMesh.createCube()`。
  * **基础材质**: 为墙壁、地面和盒子分别创建了 `StandardMaterial`，并设置了不同的 `baseColor` 和 `roughness`。
  * **面光源**: 场景中的光源不是一个抽象的光源对象，而是一个被赋予了自发光材质（`emissiveColor`）的平面几何体，这是创建物理精确面光源的标准方法。
* **学习要点**: 该脚本是学习场景构建流程的绝佳起点，清晰地展示了"创建材质 -> 创建几何体 -> 创建变换节点 -> 组合成实例"这一核心逻辑。

  ```python
  # 创建一个发光材质作为光源
  light = StandardMaterial('Light')
  light.emissiveColor = float3(17, 12, 4)
  light.emissiveFactor = 5

  # 创建一个四边形网格
  quadMesh = TriangleMesh.createQuad()

  # 将发光材质应用到四边形网格上，并将其放置在天花板位置
  sceneBuilder.addMeshInstance(
      sceneBuilder.addNode('Light', Transform(scaling=0.13, translation=float3(0, 0.549, 0), rotationEulerDeg=float3(180, 0, 0))),
      sceneBuilder.addTriangleMesh(quadMesh, light)
  )
  ```

#### 2. `material_test.pyscene` - PBR材质详解

* **用途**: 系统地、并排地展示不同PBR（Physically-Based Rendering）材质参数变化对物体外观的影响。
* **功能演示**:

  * **参数变化**: 脚本通过循环创建了一系列球体，并为每个球体赋予一个粗糙度(`roughness`)、金属度(`metallic`)或透射率(`specularTransmission`)等属性值略有不同的材质。
  * **环境光**: 使用 `EnvMap` 加载了一张HDR环境贴图，为场景提供了真实的环境照明和反射，这对于观察PBR材质（尤其是金属）的真实效果至关重要。
* **学习要点**: 当你希望深入理解某个材质参数（例如 `indexOfRefraction` 或 `thinSurface`）的具体作用时，加载此场景并观察对应的那一排球体的表现，将非常直观。

  ```python
  # 加载一个HDR环境贴图作为光源
  envMap = EnvMap('envmaps/20060807_wells6_hd.hdr')
  envMap.intensity = 1.5
  sceneBuilder.envMap = envMap

  # 通过循环创建一排球体，每个球体的金属度从 0 到 1 线性过渡
  materials = []
  for i in range(COLS):
      metallic = i / float(COLS - 1)
      material = StandardMaterial('metallic=%.2f' % metallic)
      material.baseColor = float4(0.5, 0.5, 0.5, 1.0)
      material.roughness = 0.1
      material.metallic = metallic
      materials.append(material)
  addSphereRow(materials) # addSphereRow 是脚本中定义的辅助函数
  ```

#### 3. `classroom_cir_with_led.pyscene` - 复杂场景与特殊光源

* **用途**: 演示如何在Falcor中加载和使用一个从外部建模软件导出的大型、复杂场景，并为其添加特殊光源。
* **功能演示**:

  * **导入外部模型**: 使用 `sceneBuilder.importScene()` 函数直接加载一个 `.gltf` 格式的教室模型，该模型包含了复杂的几何结构和多种预设材质。
  * **特殊光源**: 演示了如何创建和配置一个 `LEDLight` 光源，包括设置其位置、方向、功率(`totalPower`)以及光分布的朗伯指数(`lambertExponent`)。
* **学习要点**: 这个场景是处理大型项目时的典型工作流程：美术在DCC工具中创建场景 -> 导出为标准格式 -> 工程师在Falcor中加载并进行照明、渲染和分析。

  ```python
  # 从.gltf文件导入一个完整的教室场景
  sceneBuilder.importScene('classroom_cir/Classroom_cir.gltf')

  # 创建一个LED光源
  ledLight = LEDLight.create('LEDLight')
  ledLight.totalPower = 10000.0              # 设置一个非常高的功率
  ledLight.position = float3(1.589, 1.182, 3.397) # 放置在特定位置
  ledLight.direction = float3(0.962, -0.271, 0.029)
  ledLight.openingAngle = 120 * 3.14159 / 180  # 设置120度的张角
  sceneBuilder.addLight(ledLight)
  ```

#### 4. `nested_dielectrics.pyscene` - 高级光学效果

* **用途**: 测试和演示渲染器处理复杂光路的能力，特别是光线在多层透明介质之间穿梭时的折射、反射和吸收效果。
* **功能演示**:

  * **嵌套透明材质**: 场景中包含如"液体在玻璃杯中"这样的模型，光线需要正确地处理从空气进入玻璃、从玻璃进入液体、再从液体返回玻璃、最终从玻璃回到空气的完整过程。
  * **物理精度**: 准确渲染此类场景，需要 `PathTracer` 有足够高的 `Max surface bounces`（最大弹射次数）和 `Max transmission bounces`（最大透射次数），以确保光线能够完成其复杂的传播路径。
* **学习要点**: 适用于高级用户和渲染算法开发者，用于验证渲染器在处理复杂介质时的物理准确性。

  ```python
  # 脚本中会定义类似玻璃和水的材质
  glassMaterial = StandardMaterial('glass')
  glassMaterial.specularTransmission = 1.0 # 完全透明
  glassMaterial.indexOfRefraction = 1.52   # 玻璃的折射率

  liquidMaterial = StandardMaterial('liquid')
  liquidMaterial.specularTransmission = 1.0
  liquidMaterial.indexOfRefraction = 1.33   # 水的折射率
  ```
