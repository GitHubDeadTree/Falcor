# 批量导出功能：实现与错误修复说明

本文档旨在记录为 `IncomingLightPowerPass` 添加批量导出功能的过程，重点说明在此过程中遇到的编译错误、错误原因分析以及最终的修复方案和实现细节。

## 1. 已实现功能

通过本次修改，我们成功地为 `IncomingLightPowerPass` 添加了批量导出场景中所有相机视点数据的功能。目前已完成的功能包括：

*   **UI增强**：在 `IncomingLightPowerPass` 的UI中，新增了 "Batch Export" 面板。该面板包含：
    *   一个 "Frames to wait" 滑块，允许用户设置切换视点后等待渲染稳定的帧数（默认为20）。
    *   一个 "Export All Viewpoints" 按钮，用于启动整个批量导出流程。

*   **非阻塞式导出流程**：导出过程采用由帧驱动的状态机实现，不会阻塞主渲染线程。点击按钮后，程序会自动：
    1.  在当前场景的相机位置周围生成8个均匀分布的视点（相机位置）。
    2.  每切换一个视点，等待用户设定的帧数。
    3.  等待结束后，自动调用现有的导出函数，将该视点的功率和统计数据保存到磁盘。
    4.  为每次批量导出创建一个带时间戳的主目录，并在其中为每个视点创建独立的子目录，确保数据组织清晰。

*   **错误修复与API适配**：解决了实现过程中遇到的多处编译错误，使代码成功适配了项目当前的 Falcor API。

## 2. 遇到的编译错误与分析

在实现过程中，我们遇到了两轮主要的编译错误。

### 2.1 第一轮错误：函数签名与 `override` 失败

**错误信息**:
```
错误 C2039: "SharedPtr": 不是 "Falcor::Fbo" 的成员
错误 C3668: "IncomingLightPowerPass::endFrame": ...没有重写任何基类方法
```

**原因分析**:
这些错误均由 `endFrame` 函数的声明引起。首先，`Fbo::SharedPtr` 是一个错误的类型，正确的 Falcor 智能指针类型应为 `ref<Fbo>`。这个类型错误导致了连锁的语法问题。

更根本的是，`RenderPass` 基类中并没有一个可供我们重写（`override`）的 `endFrame` 虚函数。我的初衷是找到一个每帧都会被调用的函数来驱动我们的状态机，错误地选择了 `endFrame`。

### 2.2 第二轮错误：`Scene` API 不匹配

**错误信息**:
```
错误 C2039: "getCameraCount": 不是 "Falcor::Scene" 的成员
错误 C2039: "getActiveCameraIndex": 不是 "Falcor::Scene" 的成员
错误 C2039: "setActiveCamera": 不是 "Falcor::Scene" 的成员
```

**原因分析**:
这些错误表明，我们尝试使用的 `getCameraCount`, `getActiveCameraIndex` 和 `setActiveCamera` 函数在 `Scene` 类中并不存在。这是因为 Falcor 框架中相机管理的方式与我们最初假设的不同。在 Falcor 中，相机不是通过索引来管理的，而是通过 `Scene::getCamera()` 获取当前活动相机，然后直接操作该相机对象。

## 3. 修复方案与核心代码实现

为了解决上述问题，我们对代码进行了如下修改：

### 3.1 使用 `execute` 替代 `endFrame`

我们从头文件 `IncomingLightPowerPass.h` 中移除了错误的 `endFrame` 函数声明，并将状态机的驱动逻辑放入 `execute` 函数的末尾：

```cpp
// In IncomingLightPowerPass.cpp
void IncomingLightPowerPass::execute(RenderContext* pRenderContext, const RenderData& renderData)
{
    // ... existing execute logic ...

    // Drive the batch export state machine every frame
    processBatchExport();
}
```

### 3.2 重新设计视点导出策略

由于 Falcor 中没有我们假设的视点管理 API，我们重新设计了批量导出的策略：

1. 不再使用预定义的相机索引，而是在当前相机位置周围生成一系列新的视点。
2. 添加新的成员变量来存储原始相机位置和参数：

```cpp
// In IncomingLightPowerPass.h
// Camera position-based viewpoints
float3 mOriginalCameraPosition;
float3 mOriginalCameraTarget;
float3 mOriginalCameraUp;
uint32_t mTotalViewpoints = 8;

// New helper function
void setViewpointPosition(uint32_t viewpointIndex);
```

3. 实现 `setViewpointPosition` 函数，用于在环形轨道上放置相机：

```cpp
void IncomingLightPowerPass::setViewpointPosition(uint32_t viewpointIndex)
{
    if (!mpScene || !mpScene->getCamera())
        return;

    // Calculate position around a circle centered on the original target
    float angle = (float)viewpointIndex / (float)mTotalViewpoints * 2.0f * 3.14159f;
    float distance = length(mOriginalCameraPosition - mOriginalCameraTarget);

    float3 newPosition;
    newPosition.x = mOriginalCameraTarget.x + distance * std::cos(angle);
    newPosition.y = mOriginalCameraPosition.y; // Keep the same height
    newPosition.z = mOriginalCameraTarget.z + distance * std::sin(angle);

    mpScene->getCamera()->setPosition(newPosition);
    mpScene->getCamera()->setTarget(mOriginalCameraTarget);
    mpScene->getCamera()->setUpVector(mOriginalCameraUp);
}
```

### 3.3 修改批量导出的初始化和终止逻辑

我们修改了 `startBatchExport` 和 `finishBatchExport` 函数，使其使用新的相机位置策略：

```cpp
void IncomingLightPowerPass::startBatchExport()
{
    if (!mpScene)
    {
        logWarning("No scene available for batch export.");
        return;
    }

    // ... (初始化代码) ...

    // 存储原始相机位置和参数
    if (mpScene->getCamera())
    {
        mOriginalCameraPosition = mpScene->getCamera()->getPosition();
        mOriginalCameraTarget = mpScene->getCamera()->getTarget();
        mOriginalCameraUp = mpScene->getCamera()->getUpVector();
    }

    // 设置第一个视点
    setViewpointPosition(mBatchExportCurrentViewpoint);

    // ... (其他代码) ...
}

void IncomingLightPowerPass::finishBatchExport()
{
    // ... (日志记录) ...

    // 恢复原始相机位置
    if (mpScene && mpScene->getCamera())
    {
        mpScene->getCamera()->setPosition(mOriginalCameraPosition);
        mpScene->getCamera()->setTarget(mOriginalCameraTarget);
        mpScene->getCamera()->setUpVector(mOriginalCameraUp);
    }

    // ... (状态重置) ...
}
```

### 3.4 更新状态机逻辑

最后，我们修改了 `processBatchExport` 函数，使其使用固定数量的视点而不是依赖于 `getCameraCount`：

```cpp
void IncomingLightPowerPass::processBatchExport()
{
    // ... (等待和导出逻辑) ...

    mBatchExportCurrentViewpoint++;
    if (mBatchExportCurrentViewpoint >= mTotalViewpoints)
    {
        finishBatchExport();
    }
    else
    {
        setViewpointPosition(mBatchExportCurrentViewpoint);
        mBatchExportFrameCount = mBatchExportFramesToWait;
    }
}
```

## 4. 最终实现效果

通过以上修改，我们成功地解决了所有编译错误，并实现了一个更加灵活的批量导出功能。该功能不再依赖于 Falcor 中不存在的 API，而是利用现有的相机操作 API 来实现类似的效果。

最终的实现允许用户：

1. 通过 UI 设置等待帧数
2. 一键启动批量导出
3. 自动在当前相机周围生成8个均匀分布的视点
4. 为每个视点生成功率和统计数据
5. 在导出完成后自动恢复原始相机位置

这种实现方式比原计划更加灵活，因为它不依赖于预定义的相机/视点集合，而是可以在任何相机位置周围生成视点，从而获得更全面的场景光功率数据。
